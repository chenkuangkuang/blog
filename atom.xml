<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>框框之下</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kuang2.cn/"/>
  <updated>2022-04-11T02:53:32.360Z</updated>
  <id>http://www.kuang2.cn/</id>
  
  <author>
    <name>框框之下</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>站立办公的探索</title>
    <link href="http://www.kuang2.cn/2022/02/28/%E7%AB%99%E7%AB%8B%E5%8A%9E%E5%85%AC%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://www.kuang2.cn/2022/02/28/站立办公的探索/</id>
    <published>2022-02-28T22:25:00.000Z</published>
    <updated>2022-04-11T02:53:32.360Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>网上都说人到中年一身病，我却是人还没入职场，职业病就接踵而至。</p><p>第一份公司时就发现了干眼症；到半年后第二份工作时，大概因为出租屋没有配桌椅，腰痛开始时隐时现，第二天赶紧花最便宜的价格整个一套桌椅——还是手动打造的“珍品”：一块板子加上支撑杆，再从超市弄个十块钱的塑料凳。</p><p>正式工作第一年，腕管综合征的病症愈发明显。在研究了各种造型的鼠标、鼠标垫后，不得已学会了左手用鼠标。还好换手操作效果拔群，否则行业生命恐怕早早夭折。</p><p>到工作第二年的冬天，又轮到干眼症加重，甚至为此跑了一趟眼科医院，神奇地在太阳穴挨了一针。一度产生换行的想法。幸运的是又接触到热敷眼罩，干燥的空调房内还有加湿器救命，才没有再挨第二针。</p><p>虽然入行不久就各种病痛折磨，还好依然扛了下来。最让我无法再去考虑转行的，是朋友R的一句话，有病就治，有问题就解决。是的，病痛只是一时，并不会危及生命。有问题就应该解决，逃避调转车头只会换一个地方再碰壁。</p><p>于是就这样坚持至今，倒也已经逆来顺受。羡慕不了那些工作多年却毫无不适的神奇体质，脆弱如我能有今日稳定且在水平线以上的工作生活也算圆满。虽然病重依旧。</p><p>最后发现最能困扰身心，并且最影响工作效率的是腰痛。白天坐如针毡，晚上则翻来覆去，酸痛到无法入睡。</p><p>就像当年努力想办法克服干眼症一样，我也是想尽办法。</p><p>刚开始试着研究坐姿。尽可能地挺直腰背，视线平直，却发现除了加重强迫症的痛苦，并没有什么卵用。至于网上说千万不要跷二郎腿，我却发现翘腿反倒能略微加长单次坐的时间。可能是重心靠后略微放松腰部的原因。</p><p>以及研究各种椅子。虽然有了解到人体工学椅之类，却也没有真的花钱去尝试。动辄上千块的价格，也只能换来一次实验性的结论，性价比实在不高。椅子再神奇，也就是造型差异，改变不了久坐伤腰的本质。</p><p>最被推荐并且想来就知道一定有效的，当然就是站立办公了。可惜早几年“站立办公”的概念还不普及，徒然整一个桌上桌站着用电脑，有点鹤立鸡群的味道。后来公司来了个上年纪的同事，很自然地整上了站立式电脑桌。倒是给我一个感悟：其实没人在乎你那奇异的姿势，大家都很忙，能按时交付成果才是职场真谛。</p><p>于是在后一份工作时，也专门带了桌上桌，等到加班时间坐不住了就拿出来摆上。效果也还不错。其实在家里早就摆了两台显示器，一个站着用一个坐着用。而在办公室统一用笔记本，也方便搬上搬下。</p><p>这就是我站立办公的第一阶段了。笔记本+床上桌，二十来块钱的方案。</p><p>中间疫情突发，意外在老家滞留三个多月。居家办公两个多月，也是得亏找到个电脑桌架在原来的桌子上。站累了干脆就趴在床上干活。</p><p>短暂而美好的居家办公生活结束后，找工作本身远不及新办公室工作的站立办公问题更能困扰我。尤其是去大厂——只能说是相比以前待的小厂，迷你厂更大的——后，在上百人共呼吸的陌生环境，恐怕不太好意思架一个桌上桌搞得太独树一帜。</p><p>又一次幸运的是，最后选择接受前前同事大哥的邀请，来到他几个人的办公室。既然是熟人，也就不必太多虑。唯一的问题是再接受福利般的双显示器后，原本就不宽敞的办公桌更显拥挤，再架台上桌怕是要把两块27寸的显示器挤到地上去。经过多个电商平台的浏览查找研究分析，终于让我找到第二种解决方案：落地支架笔记本桌。</p><p style="text-align:center"><img src="/images/多宝莱站立办公桌.jpg" style="width:35%" title="多宝莱站立办公桌" alt="多宝莱站立办公桌"></p><p>其前身貌似是做直播的支架副产品，换上600mm长的木板刚好能做笔记本桌面。而且这样能给我续命的好东西，竟然只要几十块钱——不过我选择继续发扬羊毛党本色，在海鲜市场淘了个二手。最后四五十块钱就解决了问题。唯一美中不足的是不能快速切换站坐姿态。每次还得台式机保存提交，开笔记本，再拉取更新，微信、浏览器各种软件都得重登。</p><p>于是继续探索其他性价比方案。目前的考虑是增加一块便携屏，架到站立位置，连上HDMI切换器，可以实现一键切换站坐。问题是如果为了性价比去买一块小商家DIY的便携屏，是否能经受那些网上在售的夹屏工具的持久“夹击”。并且显示器总要连视频输入和电源两根线，对于目前的小桌面也是一大考验。</p><p>最近发现并快速实施的方案是：台上显示器增高架。本质上是普通显示器增高架的升级版，只是将高度拉伸到站立的可视范围。不过配合床上桌，换掉家里的垃圾桶+垫书，也是一大优化项了。</p><p style="text-align:center"><img src="/images/显示器增高架.jpg" style="width:35%" title="显示器增高架" alt="显示器增高架"></p><p>网上虽然有各种或高级或极具性价比的升降电脑桌，我却自认为已将自身需求满足到极致（受限于已有条件）：或者追求双大屏办公，只能配合笔记本做站立方案；或者实现了一键切换姿态，只是牺牲了更大空间，没法兼容双屏。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;网上都说人到中年一身病，我却是人还没入职场，职业病就接踵而至。&lt;/p&gt;&lt;p&gt;第一份公司时就发现了干眼症；到半年
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.kuang2.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="杂感" scheme="http://www.kuang2.cn/tags/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>结束不了的疫情及其他</title>
    <link href="http://www.kuang2.cn/2022/02/24/%E7%BB%93%E6%9D%9F%E4%B8%8D%E4%BA%86%E7%9A%84%E7%96%AB%E6%83%85%E5%8F%8A%E5%85%B6%E4%BB%96/"/>
    <id>http://www.kuang2.cn/2022/02/24/结束不了的疫情及其他/</id>
    <published>2022-02-24T23:02:00.000Z</published>
    <updated>2022-04-11T02:53:32.360Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>这两天又有一波疫情席卷而来，就像两年前那样的“幸运”，不偏不倚，又是近在咫尺，从办公隔壁的小区，到住处隔壁的小区，再到小区旁边几栋的单元……</p><p>可惜经过两年洗礼，不该习惯的也习惯了。放眼望去全球大势，我们国家总归自身难保。除非能像隔壁闭关锁国，否则清零政策迟早无以为继。所以不如放平心态，只做这苟且又谨慎的准备即好。</p><p>以前总想着未来会如何如何，却怎么也无法预料到有如此宏大的“黑天鹅事件”，裹挟全部人类，无处可逃。不幸患病甚至病重而亡固然可怜可悲，更让人感觉悲伤的是看不到结束，没有任何可能恢复到以往的生活——那常常被厌弃如今却分外怀念的平常生活。</p><p>幸运的是就我们一家而言，从工作收入上，因为行业原因，没有遭受明显打击。影响主要还是生活的不便，诸如户外活动减少，戴口罩加重鼻炎，不得不打消各种出游的计划等等。当然我也深知那遭受更大厄运的千千万万人们，因为收入减少，健康失去，从而直接或间接降低了整个社会的幸福熵值，受其波动传导，最终也影响到我们这一家自身——或者是经济的衰退，或者是风气的改变，等等。</p><p>出门必戴口罩，若有似无的消毒水味，隔三差五的疫苗接种和核酸检测……在像我家宝宝这样的疫情后一代以后看来，会不会就是生活的一部分呢？却无法想象没有这些的日子是什么样。</p><p>可以想象，对于大多数没有遭遇病毒的多数人（中国的多数，国外的少数），在工作生活影响之外，最大的变化就是聚会少了，活动少了。那些没来由同时也没意义的公司聚餐终于消停，同时和朋友同事的约会活动也屈指可数。影院票房骤减，餐馆远不如彼时红火，KTV更是萧条到变成夕阳产业——当然这些也可能跟我周边的同龄人都进入已婚已育状态有关，简言之就是带娃比疫情更能缩减一个人的社交娱乐生活。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;这两天又有一波疫情席卷而来，就像两年前那样的“幸运”，不偏不倚，又是近在咫尺，从办公隔壁的小区，到住处隔壁的小
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.kuang2.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="杂感" scheme="http://www.kuang2.cn/tags/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>快读推理小说</title>
    <link href="http://www.kuang2.cn/2021/09/30/%E5%BF%AB%E8%AF%BB%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AF%B4/"/>
    <id>http://www.kuang2.cn/2021/09/30/快读推理小说/</id>
    <published>2021-09-30T20:03:00.000Z</published>
    <updated>2022-04-11T02:53:32.356Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>最近接连读了好些本推理/悬疑小说。本来是对着豆瓣评分上的车，平均不低于 7.5，但实际感受却是天差地别。下面详细说说。</p><p>《体育馆杀人事件》青崎有吾。氛围渲染和故事推进的很棒，主角做的嫌疑人排除是最大亮点，排除某些睁眼瞎的 bug，也算是我见过最严密的推理了，尤其是末尾叙诡的不在场证明排除那段。结局则有点失望，还以为是啥精巧的设计，结果就这？动机还行。人物塑造糟糕。</p><p>《字母表谜案》大山诚一郎。看完第一篇想吐……第一次被豆瓣评分骗出内伤。后经网友提示说最后一篇才是神作，于是耐着性子把那极度煽情又冗长的故事看完了。诡计设计还行吧。但也就接近近几年大部分伪高分国产悬疑剧的水准。结果凶手的指认再一次差点把我肝出大出血。</p><p>《Y 的悲剧》埃勒里·奎因。古典推理大师的作品。在氛围渲染上有阿加莎（《无人生还》）的风范。极具年代感下的各种人物也很有意思。故事给人的爽感能到 80 分，扣掉的 20 分要怪凶手和动机。给人的感觉就是好像是挺悲剧的，但没太明白到底悲剧在哪。性格 or 疾病？就当遗传神经质吧。</p><p>《一场事先张扬的凶杀案》马尔克斯。当然不算推理，但读起来很爽，毕竟是世界级纯文学大师，二流子推理门类不能比的。很短的一件事写成各种视角下的长篇，如此简单的故事还能经过一层层的递进，考虑到人物不多， 没有太大的人名记忆负担，总体体验可以超过大师的另两篇名著《百年孤独》和《霍乱时期的爱情》。缺点是角色的感情线，莫名其妙没头没尾，跟《霍乱》的死脑筋一脉相承吧。</p><p>《三口棺材》狄克森·卡尔。诡计设计最好的一本。经历过多年柯南熏陶，其实也能轻松猜到一半以上的答案。但还是被剩余的谜底惊艳到了。缺点是主角侦探的人物塑造，给人一种很玄乎的感觉。三个人的奇怪组合导致废话多了很多。</p><p>《七个证人》西村京太郎。同样日本人的作品。应该分类为本格推理，但实际感觉同样是本格过度了。换句话说就是老子只讲解谜，线索证据啥的统统当不存在。具体到这本，前半段总是一副云里雾里的主角侦探，到后半段突然柯南附身，一下子就把案子梭哈了。智商值之暴涨让人莫名其妙。布局和动机倒是亮点。</p><p>《火之幻影》陈舜臣。莫名眼熟的一个作者。这本书被作者称之为“最得意”，看了前半段得出结论是这作者也就网文水平。后半段开始发力，连续反转让人眼花缭乱，至少这“得意”是保住了。结局稍弱。总体能到豆瓣 8.5 以上。</p><p>《犹大之窗》狄克森·卡尔。三口棺材同作者。气氛渲染的风格类似。故事讲述则完全不同——把剧情完全放在法庭的辩论席上，给人的感觉就是线索和推理递进很严密。缺点是在密室里用了机关，个人感觉这样就违背密室诡计的初衷了。差评。总体上还算是作者高水准的一篇。</p><p>《解体诸因》西泽保彦。没看完。短篇集。剧情完全就是字面意思，分尸的各种原因（这样一说起名还挺文艺）。诡计在水平线以上吧。同样是日本作家作风的只管解谜不讲证据和线索的迷之推理。因为每篇都差不多就没兴趣看完了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;最近接连读了好些本推理/悬疑小说。本来是对着豆瓣评分上的车，平均不低于 7.5，但实际感受却是天差地别。下面详
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.kuang2.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.kuang2.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>重读react官方文档</title>
    <link href="http://www.kuang2.cn/2021/09/05/%E9%87%8D%E8%AF%BBreact%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    <id>http://www.kuang2.cn/2021/09/05/重读react官方文档/</id>
    <published>2021-09-05T10:58:00.000Z</published>
    <updated>2022-04-11T02:53:32.360Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>最近重读了一遍 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">react官方文档中文版</a>，又得了些读书笔记：</p><h3 id="1-ref的使用注意事项"><a href="#1-ref的使用注意事项" class="headerlink" title="1.ref的使用注意事项"></a>1.ref的使用注意事项</h3><ul><li>只能用在dom节点和class组件上，如果要用在function组件，使用React. forwardRef暴露给父组件（ref转发，forward向前的意思）并在useImperativeHandle中定义父组件可调用的子组件方法</li></ul><h3 id="2-lt-gt-lt-gt-插入key"><a href="#2-lt-gt-lt-gt-插入key" class="headerlink" title="2.&lt;&gt;&lt;/&gt;插入key"></a>2.&lt;&gt;&lt;/&gt;插入key</h3><p>&lt;&gt;&lt;/&gt;实际上是&lt;React.Fragment&gt;的简写模式，所以当要增加key时，可以这些写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;props.items.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">     <span class="comment">// 没有`key`，React 会发出一个关键警告</span></span><br><span class="line">     &lt;React.Fragment key=&#123;item.id&#125;&gt;</span><br><span class="line">        &lt;dt&gt;&#123;item.term&#125;&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">        &lt;dd&gt;&#123;item.description&#125;&lt;/</span>dd&gt;</span><br><span class="line">     &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">))&#125;</span></span><br></pre></td></tr></table></figure><p>key属性是React.Fragment唯一支持的属性</p><h3 id="3-不要在render中使用HOC（高阶组件）"><a href="#3-不要在render中使用HOC（高阶组件）" class="headerlink" title="3.不要在render中使用HOC（高阶组件）"></a>3.不要在render中使用HOC（高阶组件）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// 每次调用 render 函数都会创建一个新的 EnhancedComponent</span></span><br><span class="line">  <span class="comment">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class="line">  <span class="keyword">const</span> EnhancedComponent = enhance(MyComponent);</span><br><span class="line">  <span class="comment">// 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EnhancedComponent</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>类似于在render中重新定义组件的问题都要注意</p><h3 id="4-如果useState的初始state需要经过复杂计算得到，可以使用setState-func"><a href="#4-如果useState的初始state需要经过复杂计算得到，可以使用setState-func" class="headerlink" title="4.如果useState的初始state需要经过复杂计算得到，可以使用setState(func)"></a>4.如果useState的初始state需要经过复杂计算得到，可以使用setState(func)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = someExpensiveComputation(props);</span><br><span class="line">  <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此函数只会在初始渲染时执行一次</p><h3 id="5-useEffect的执行时间"><a href="#5-useEffect的执行时间" class="headerlink" title="5.useEffect的执行时间"></a>5.useEffect的执行时间</h3><p>默认情况下，useEffect包裹的函数，将在每轮渲染结束后执行（一个延迟事件中被调用）；</p><p>如果想要在绘制前执行，请使用 useLayoutEffect</p><p>return的清除函数，会在执行下一个effect之前</p><h3 id="6-useEffect的注意事项"><a href="#6-useEffect的注意事项" class="headerlink" title="6.useEffect的注意事项"></a>6.useEffect的注意事项</h3><ul><li>尽量在useEffect中声明会调用的函数，而不是调用外部函数，因为这样容易以为没有用到某些props或state，而没有声明必要的依赖数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(someProp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 这样不安全（它调用的 `doSomething` 函数使用了 `someProp`）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(someProp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doSomething();</span><br><span class="line">  &#125;, [someProp]); <span class="comment">// ✅ 安全（我们的 effect 仅用到了 `someProp`）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理组件卸载后请求响应回调的setData引发的报错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ignore = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(<span class="string">'https://hn.algolia.com/api/v1/search?query='</span> + query);</span><br><span class="line">      <span class="keyword">if</span> (!ignore) setData(result.data);</span><br><span class="line">    &#125;</span><br><span class="line">    fetchData();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; ignore = <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;, [query]);</span><br></pre></td></tr></table></figure><h3 id="7-使用reducer处理深度的props回调函数传递"><a href="#7-使用reducer处理深度的props回调函数传递" class="headerlink" title="7.使用reducer处理深度的props回调函数传递"></a>7.使用reducer处理深度的props回调函数传递</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodosDispatch = React.createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodosApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 提示：`dispatch` 不会在重新渲染之间变化</span></span><br><span class="line">  <span class="keyword">const</span> [todos, dispatch] = useReducer(todosReducer);</span><br><span class="line">  <span class="comment">// 内部组件树里的任何子节点都可以使用 dispatch 函数来向上传递 actions 到 TodosApp</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;TodosDispatch.Provider value=&#123;dispatch&#125;&gt;</span><br><span class="line">      &lt;DeepTree todos=&#123;todos&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/TodosDispatch.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="8-useRef和createRef的区别"><a href="#8-useRef和createRef的区别" class="headerlink" title="8.useRef和createRef的区别"></a>8.useRef和createRef的区别</h3><p>定义区别：useRef相当于this，是一个容器，用于存放任意变量；createRef专用于dom的引用</p><p>使用区别：createRef用于class组件获取dom，放在构造函数中只执行一次，如果放在函数组建中会每次render执行</p><p>本质区别：createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [renderIndex, setRenderIndex] = React.useState(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> refFromUseRef = React.useRef();</span><br><span class="line">  <span class="keyword">const</span> refFromCreateRef = createRef(); <span class="comment">// 每次render重新返回新的引用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!refFromUseRef.current) &#123;</span><br><span class="line">    <span class="comment">// 第一次初始化之后，就不再进入判断，所以这个值停留在1</span></span><br><span class="line">    refFromUseRef.current = renderIndex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!refFromCreateRef.current) &#123;</span><br><span class="line">    <span class="comment">// 每次render都重新进来，所以这个值一直跟随renderIndex更新</span></span><br><span class="line">    refFromCreateRef.current = renderIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;Current render index: &#123;renderIndex&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;b&gt;refFromUseRef&lt;/</span>b&gt; value: &#123;refFromUseRef.current&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;b&gt;refFromCreateRef&lt;/</span>b&gt; value:&#123;refFromCreateRef.current&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setRenderIndex(prev =&gt; prev + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Cause re-render</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><p>使用技巧1：使用useRef显示上一个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> preCountUseRef = useRef();</span><br><span class="line">    <span class="comment">// 为什么保存的是上一个值：因为useEffect是渲染之后执行，而useRef的修改不会触发render</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        preCountUseRef.current = count;</span><br><span class="line">    &#125;); <span class="comment">// 没有第二个参数，则每次render之后都执行</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;preCount: &#123;preCountUseRef.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;You clicked &#123;count&#125; times&lt;/</span>p&gt;</span><br><span class="line">&lt;button onClick=&#123;()=&gt;setCount(count+<span class="number">1</span>)&#125;&gt;Click me&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用技巧2：封装成自定义hook：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> usePrevious = <span class="function"><span class="params">state</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ref = useRef();</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ref.current = state;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ref.current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义hook</span></span><br><span class="line"><span class="keyword">const</span> preCount = usePrevious(count);</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;最近重读了一遍 &lt;a href=&quot;https://zh-hans.reactjs.org/docs/forwa
      
    
    </summary>
    
      <category term="技术" scheme="http://www.kuang2.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS JS基础 React" scheme="http://www.kuang2.cn/tags/JS-JS%E5%9F%BA%E7%A1%80-React/"/>
    
  </entry>
  
  <entry>
    <title>如何拯救一岁宝宝的精神生活</title>
    <link href="http://www.kuang2.cn/2021/08/26/%E5%A6%82%E4%BD%95%E6%8B%AF%E6%95%91%E4%B8%80%E5%B2%81%E5%AE%9D%E5%AE%9D%E7%9A%84%E7%B2%BE%E7%A5%9E%E7%94%9F%E6%B4%BB/"/>
    <id>http://www.kuang2.cn/2021/08/26/如何拯救一岁宝宝的精神生活/</id>
    <published>2021-08-26T20:11:00.000Z</published>
    <updated>2022-04-11T02:53:32.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>宝宝一岁以后，吃和睡逐渐规律，空闲时间反倒多了起来。</p><p>在把每个房间每张抽屉清点倒腾一番之后，失去了对这个九十平小屋的探索兴趣，只能像遛狗一样每天带出去溜达几圈。然而疫情反复，活动大受限制；天空也不争气，打开天气预报，常常一整排的雨水播报。无奈之下，还是得加强玩具装备的补充。</p><p>考虑到该年龄段短暂如流星的注意力，我优先考虑的是低价、大量的玩具购买策略。开上两个拼爹爹月卡，每周一张五毛无门槛券，应该差强人意了吧？经过这样几个月的玩具选购经历，对于玩具的采买和孩子的兴趣才终于有了一个基本的把握。</p><p>先说说我家最“高寿”的玩具，就是孩子爷爷在大半岁的时候就“高价”买入的两个电动小玩意。一个是按下能发声的小电话，一个是拨动开关就开始疯狂翻跟头的小猴。起码服役了大半年。</p><p>这两货昭示着一个玩具界的真理：宜动不宜静。这是我在后来又购入一堆玩意儿才领悟到的。</p><p>在宝宝开始会走之后，我首先购入的是小球和发条玩具。在不太会走的时候，第一次看到拧上发条就一蹦一蹦往前走的小恐龙，宝宝眼睛都要发光了。至于小球，则是整天价的在屋子里扔来扔去，五个小的，五个大的，再加上别处淘来的乒乓球等等，结果都扔得不知所踪。</p><p>接着迷上了推车，一会推自己坐的小推车，一会推家里的凳子椅子，还有继承自表哥家的学步车。后来以12块钱极高的性价比买了一只小鸭子推车，玩得不亦乐乎。几个月下来，依然还是最喜欢玩具排行榜头几名。后来买了个能装水果蔬菜模型的篮子推车，也是经常在家里推来推去。</p><p>宝宝在同龄孩子里走得早，好动，关键是腿有劲。也难怪她爱玩球，又爱推车。只要走起来，跑起来，动起来，她就可以乐呵一整天。真是所谓“屁颠屁颠”。</p><p>一个特例是玩具车。不管是惯性一推就跑老远的，还是回力往后拉放手就能冲出去的，或者可以变形翻转的，都不感兴趣。唯一玩过几次的一个小摩托车，仅仅是因为上面有个按钮一按就会发声发光。似乎车车（静态玩具车）真的可以作为区分男宝和女宝的鉴定神器。</p><p>然后买了迷你图书。九块九五十本，每本不到十页的内容。虽然还不会说话，却出乎意料地吸引了不少注意力。在被动接受地“教育”了几次之后，竟然还经常主动拿起几本推给你，意思是让你讲。讲到喜欢之处（前提是讲得抑扬顿挫，必要时候模仿下故事里面的动物语气），竟然手舞足蹈，乐不可支。时间长了还有挑有捡，只愿意反复看喜欢的那几本。</p><p>可惜纸做的书不比塑料，经不起折腾，没多久就掉的掉，破的破。接着我又试着买了硬壳的洞洞书，借了楼下表哥孩子的绘本，又充实了一阵子。可惜就像一阵风过，最近也不爱看了。倒是买的一本表哥家同款的发声书，每天都要打开往上面乱按一回。兴趣点也简单直白，只看动物、水果和音乐。</p><p>尤其是音乐。音乐对于我家宝宝就像精神生活的刚需，是上瘾一般的所在。每次音乐一响，不管当时是什么姿势，都要挣扎着站起来，开始上下扭动，仿佛是触动了身体里的某个机关。这也是为什么有些玩具能脱颖而出：能放音乐，就是好玩具。</p><p>经过仅仅是短短几个月的优胜劣汰，就算是瞎子也能看出能留住孩子注意力的是哪些东西。依然还是那些电动的、能发声发光的玩意儿。虽然明知电动玩具因为要装电池（or充电），使用有安全风险，维护也麻烦，并且在触发脑部活动上起不到啥作用——就像大人最舒服的阅读还得是看视频——但不得不承认这样的玩具起码不会浪费钱。</p><p>但万万不可污名化电动玩具。至少在我这几个月的选购经历之下，还是能找出一些经典有趣也不脑残的电动玩具。不妨推荐几款。</p><p>比如翻转猴。</p><p>比如扭扭鸭。</p><p>千万不要去买些大人都觉得无聊的玩意儿。如果大人都能乐在其中，那孩子一定不会失望。比如最近购入的一个哆啦A梦遥控车。</p><p>最后轮到那个经典问题：孩子的玩具，会不会太多了。有的人觉得，我们那代孩子根本没啥玩具可玩，还不是一样健康活泼乖乖长大了。我觉得这样的想法太双标了。大人的努力拼搏，不就是为了给孩子创造更好的环境，不管这种环境是关于物质的，还是关于精神的。从某种意义上来说，更多的培训班，还是更多的玩具，都是一回事。</p><p>而且在这点上又有我的一点私心。就是跟表哥家孩子的比较，人家的玩具才叫真的多，每次我家宝宝去他们家都可以玩好久。某次他家孩子上来，说不知道玩什么玩具，虽然我家宝贝还不会说话，却极其“懂事”的把围栏里的一堆抱了出来——多半是玩了大半年以上已经没啥可玩性的玩意儿——让我忍不住有些心疼，瞬间觉得我家宝宝也还没有享受到太多更好的物质和精神生活。至于以后的择校、是否能进高级的幼儿园和小学，暂且不提。至少在一两岁的档口，买几个几十块钱的玩具，多几分快乐，还是应该的吧。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;宝宝一岁以后，吃和睡逐渐规律，空闲时间反倒多了起来。&lt;/p&gt;&lt;p&gt;在把每个房间每张抽屉清点倒腾一番之后，失去了
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.kuang2.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="杂感" scheme="http://www.kuang2.cn/tags/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>奥运会，爱国会</title>
    <link href="http://www.kuang2.cn/2021/08/13/%E5%A5%A5%E8%BF%90%E4%BC%9A%EF%BC%8C%E7%88%B1%E5%9B%BD%E4%BC%9A/"/>
    <id>http://www.kuang2.cn/2021/08/13/奥运会，爱国会/</id>
    <published>2021-08-13T22:23:00.000Z</published>
    <updated>2022-04-11T02:53:32.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>一年从头望到尾，日子淡如水。举世瞩目又令人振奋的事情不多，四年一次的奥运绝对算一个。</p><p>今年的奥运关注度不小，首先是16年的东京八分钟吊足了胃口，接着因为疫情的推迟，差点成了近代史第一届被取消的奥运会。尽管亏损几百亿，日本政府还是咬着牙办了下来，给几十亿为疫情所苦的地球人——以及十几亿为八卦所苦的中国人——平添不少茶余饭后的谈资，至少在这点上该感谢日本人，菅义伟同志的奥林匹克奖章所得不亏。</p><p>就是可惜了开幕式，望穿秋水，却是梦幻泡影。没有哆啦A梦，没有马里奥，更没有迪迦和赛罗。有人说，就算开幕式放两小时的动漫混剪，也比现在这个“阴间”表演好看一百倍。据说开幕式背后有一些内斗，以及财团撤资的传言。可惜没有如果，有的只是苏炳添们的龟派气功cosplay罢了。</p><p>中国队的此番出征则超出预期，收获38金共88枚奖牌，平了往年的海外记录，好些冷门项目创造历史或打破纪录。导致网上有关现任体育局长的梗流传甚广：</p><p style="text-align:center"><img src="/images/奥运苟局梗.png" style="width:35%" title="奥运苟局梗" alt="奥运苟局梗"></p><p>对于争得第一名甚至制霸某项目的运动员们，从个人的角度来说，我当然是衷心地祝贺和无比地钦佩，他们无数个日夜的训练值得这份荣誉。但从国家的角度，却偶尔会冒出怀疑的想法：同样是奋斗若干年，却一直居于人后的奥恰洛夫、李宗伟们，是否也值得拥抱一次这样的耀眼时刻呢？</p><p>比如在乒乓球台上，中国队作为绝对统治力的存在，无数次包揽金银牌。让人忍不住担心在其他国家，乒乓这项运动是否还有吸引力可言。这也是养狼计划的由来，官方出马，主动去交流技术，帮助别国培育乒乓球手，以致在混双上憾失历史首枚金牌。因果循环，倒也无可怪罪。</p><p>赛场没有仁慈，奥运不是慈善。希望这只是我个人的怪想。就像波尔也说过，如果没有中国队，他早就拿到大满贯了；但他同时也说，可要是没有中国队，拿再多冠军又有什么挑战呢。</p><p>奥运是个体育的盛会，同时也是爱国的盛会。爱国热情随着赛场的胜负起落。这场四年一届的盛会，是规模最宏大的肾上腺素触发机制。无数人义愤填膺，摇旗呐喊，为祖国队伍万里加油，为家乡健儿的胜利欢呼。看到同种同胞们站上最高奖台，听国歌奏响，也不禁眼含热泪，与有荣焉。</p><p>如果把爱国定义为对本族群的认可，那我觉得小S所经历的风波倒有点莫名其妙。就像宁波人追捧杨倩，湛江人歌颂全红婵，同理香港人支持香港健儿，台湾人点赞台湾运动员，皆为同理。至于“国手”云云，不过是岛内习惯性称呼，让肉身居于台北的徐熙娣养成大陆人的自觉，可以算是所托非人，难孚众望了。身在墙内的国人，可能无法理解墙外的通行语言习惯。打个比方来说，作为gis地图技术行业相关人士，可以提供一个残酷的事实：在github——github是全球代码开源平台、全球程序员开放个人代码网站、gay交友社区（误）——上由外国人提供的开源世界地图数据中，没有一个把taiwan放在china之内。</p><p>不必辛酸，更犯不着愤怒。作为某种模糊地带的敏感边界，这就是可见的事实，尽管墙内的事实与墙外的事实稍有出入。回想下此前屡屡发生的外国企业网站上，地图或国家的归属问题，一切就会豁然开朗。外国人不会理解国人对说辞的较真，对地图的禁忌；就像国人也对美国黑人在美国到底是个啥地位摸不着头脑。</p><p>爱国这件事，是值得好好说道说道的。梁文道说，融入大我的崇高可以消弭个人生活上那微不足道的缺陷。简言之，爱国是尊严的化肥，属于好东西那一类。然而近些年来，至少从微博这个小世界中，却能窥见一些不让人舒服的色彩。这一点从当年柴静、刘瑜的消失，到最近大象公会、回形针的倒掉，已经可见一斑。</p><p>在河南水灾后，热心民众和企业纷纷捐款，慷慨解囊，微博上却又开始了捐款金额大比拼，瞧哪个明星没捐款调查大赛。当年地震后王石提出的“捐款要设上线”倡议，如同投入大海的雨，余波难觅。至于捐款收集大户“壹基金”在创立之初提倡的“每人每月一块钱”，更成了一场空谈。</p><p>另一方面，因为倾囊相助而爆火的鸿星尔克，成了爱国民众的团宠。这倒是好事。国货崛起提了多年，如今也只见到大疆、华为、tiktok这样的IT界代表，是需要点实体行业出来亮亮相了。然而遽然晋升为“爱国品牌”的鸿星尔克，似乎还未完全匹配此身份。毕竟当下标榜爱国品牌的，反而多是些打着爱国旗号，干着收割智商税的混色企业（此处点名某想，花粉饶命）。</p><p>企业如此，个人亦然。可以轻松观察到的现象是，越是喜欢标榜爱国心的明星，越是在大陆市场赚得盆满钵满。比如向太向佐之流。这叫政治嗅觉优先于业务能力。反过来说，越是想在国内市场立稳脚跟的，越需要站好队伍，表足姿态。比如央视现场编曲祖国万岁的某GAI，再比如每次国家级事件发生时，那一长串的明星转发微博名单。</p><p>最后想到的是摘得奥运首金的杨倩，微博杨大妞。夺冠之后，本来毫无人气的微博被狂热的粉丝攻陷，粉丝数暴涨，但很快有人发现杨倩此前晒过耐克的鞋。于是评论里一片骂声，直到有人指出那是在新疆棉事件发生前拍的。现在奥运已经结束几天，那张照片也似乎早早被删除了。然而个人却觉得不必删，不该删。穿鞋是自由，爱国也是自由。何必以某种自由去指摘另一种自由呢？况且行胜于言，为祖国争得荣誉，不知道比手拿键盘的爱国人士高到哪里去了。</p><p>爱国到底还是属于道德的范畴，但又不该和道德混为一谈。如果以道德标准而论，应该遵循的还是九百年前南宋思想家陈亮的那句铮铮格言，“严于律己，宽以待人”。而从爱国爱家这独一无二的情感出发，陈独秀说得更好：“我以为若是用理性做感情冲动的基础，那感情才能够始终热烈坚固不可摇动。”</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;一年从头望到尾，日子淡如水。举世瞩目又令人振奋的事情不多，四年一次的奥运绝对算一个。&lt;/p&gt;&lt;p&gt;今年的奥运关
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.kuang2.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="杂感" scheme="http://www.kuang2.cn/tags/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>leaflet插件推荐之如何处理大量点位</title>
    <link href="http://www.kuang2.cn/2021/07/13/leaflet%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B9%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E7%82%B9%E4%BD%8D/"/>
    <id>http://www.kuang2.cn/2021/07/13/leaflet插件推荐之如何处理大量点位/</id>
    <published>2021-07-13T21:48:00.000Z</published>
    <updated>2022-04-11T02:53:32.344Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><h3 id="1-Leaflet-markercluster-点位聚合"><a href="#1-Leaflet-markercluster-点位聚合" class="headerlink" title="1.Leaflet.markercluster 点位聚合"></a>1.<a href="https://github.com/Leaflet/Leaflet.markercluster" target="_blank" rel="noopener">Leaflet.markercluster</a> 点位聚合</h3><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'leaflet.markercluster'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./MarkerCluster.css'</span>;</span><br><span class="line"></span><br><span class="line">markerClusterGroup = L.markerClusterGroup();</span><br><span class="line"></span><br><span class="line">markerClusterGroup.addLayer(marker);</span><br><span class="line"></span><br><span class="line">map.addLayer(markerClusterGroup);</span><br></pre></td></tr></table></figure><p><a href="https://leaflet.github.io/Leaflet.markercluster/example/marker-clustering-realworld.388.html" target="_blank" rel="noopener">点击查看demo</a></p><h3 id="2-Leaflet-PixiOverlay"><a href="#2-Leaflet-PixiOverlay" class="headerlink" title="2.Leaflet.PixiOverlay"></a>2.<a href="https://github.com/manubb/Leaflet.PixiOverlay" target="_blank" rel="noopener">Leaflet.PixiOverlay</a></h3><p>使用Pixi.js绘制叠加层，Pixi.js是一个使用 WebGL 绘制的 JavaScript 库</p><p><a href="https://manubb.github.io/Leaflet.PixiOverlay/french-cities.html" target="_blank" rel="noopener">点击查看demo</a></p><h3 id="3-leaflet-markers-canvas"><a href="#3-leaflet-markers-canvas" class="headerlink" title="3.leaflet-markers-canvas"></a>3.<a href="https://github.com/lipton-ice-tea/leaflet-canvas-markers" target="_blank" rel="noopener">leaflet-markers-canvas</a></h3><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./leaflet-markers-canvas.min.js'</span>);</span><br><span class="line"></span><br><span class="line">markersCanvas = <span class="keyword">new</span> L.MarkersCanvas();</span><br><span class="line"></span><br><span class="line">markersCanvas.addTo(map);</span><br><span class="line"></span><br><span class="line">markersCanvas.addMarker(marker, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><a href="https://lipton-ice-tea.github.io/leaflet-canvas-markers" target="_blank" rel="noopener">点击查看demo</a></p><h3 id="4-leaflet-canvas-markers"><a href="#4-leaflet-canvas-markers" class="headerlink" title="4.leaflet.canvas-markers"></a>4.<a href="https://github.com/corg/Leaflet.Canvas-Markers" target="_blank" rel="noopener">leaflet.canvas-markers</a></h3><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./leaflet.canvas-markers'</span>;</span><br><span class="line"></span><br><span class="line">markersCanvas = L.canvasIconLayer(&#123;&#125;).addTo(map);</span><br><span class="line"></span><br><span class="line">markersCanvas.addOnClickListener(<span class="function"><span class="keyword">function</span>(<span class="params">e, arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = arr[<span class="number">0</span>].data;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ciLayerref.current.addLayers(markers);</span><br></pre></td></tr></table></figure><p><a href="https://ejuke.github.io/Leaflet.Canvas-Markers/examples/index.html" target="_blank" rel="noopener">点击查看demo</a></p><p>使用插件leaflet.canvas-markers在缩放时，图标的缩放会产生延迟，使用<a href="https://github.com/corg/Leaflet.Canvas-Markers" target="_blank" rel="noopener">fork的分支</a></p><h3 id="5-canvas-marker如何使用自定义颜色的图标？"><a href="#5-canvas-marker如何使用自定义颜色的图标？" class="headerlink" title="5.canvas marker如何使用自定义颜色的图标？"></a>5.canvas marker如何使用自定义颜色的图标？</h3><p>之前项目的一个核心需求就是可以自定义图标颜色，然而canvas marker类插件只支持固定的图片图标。难道要制作N个不同颜色的图标文件吗？</p><p>百般研究之后，我的解决方案是（把原来的SVG图标文件）————转成cavans函数绘制，然后颜色值作为fillcolor传参</p><p>使用 <a href="http://demo.qunee.com/svg2canvas/" target="_blank" rel="noopener">svg2canvas</a> 工具即可</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;1-Leaflet-markercluster-点位聚合&quot;&gt;&lt;a href=&quot;#1-Leaflet-
      
    
    </summary>
    
      <category term="技术" scheme="http://www.kuang2.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://www.kuang2.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JS" scheme="http://www.kuang2.cn/tags/JS/"/>
    
      <category term="leaflet" scheme="http://www.kuang2.cn/tags/leaflet/"/>
    
  </entry>
  
  <entry>
    <title>从长安十二时辰到马伯庸</title>
    <link href="http://www.kuang2.cn/2021/06/16/%E4%BB%8E%E9%95%BF%E5%AE%89%E5%8D%81%E4%BA%8C%E6%97%B6%E8%BE%B0%E5%88%B0%E9%A9%AC%E4%BC%AF%E5%BA%B8/"/>
    <id>http://www.kuang2.cn/2021/06/16/从长安十二时辰到马伯庸/</id>
    <published>2021-06-16T20:11:00.000Z</published>
    <updated>2022-04-11T02:53:32.348Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>看完了长安十二时辰，这是最近第二本让人热血沸腾的小说了（前一本是乔治马丁的《沙王》）。妹想到浓眉大眼的马亲王也能写出如此让人欲罢不能的小说了。遥想之前《古董局中局》《我读书少，你可别骗我》等一系列让人打瞌睡的故事，其节奏把控能力、情节设置能力竟然突飞猛进到如此地步。让人怀疑是不是哪天在梦中得了马丁老头的真传。</p><p>唯一不变的，依然是亲王的脑洞。关于这本小说，他也说了，是某天玩游戏突发奇想，把刺客信条的故事放在古代会是什么样。再套上《24小时》的框架，一本精彩纷呈的历史（架空？）小说就这么诞生了。</p><p>挖脑洞一直是马伯庸的特长。从我第一次接触到他的作品，科幻世界上的《寂静之城》——讲述未来某天世界被全方位监听，笔上写的，嘴上说的都有了禁忌，当局甚至每天公布敏感词清单——到最喜欢的短篇《末日焚书》——讲述末日来临，必须靠烧书取暖，关于如何选书烧的问题——和最喜欢的知乎回答《什么叫做新闻写作中的“华尔街新闻体”和“倒三角体》——讲述如何用不同新闻社的特色笔法报道鸿门宴，都能看出，脑洞生发才是他小说的第一催动力。</p><p>细心的观众应该能发现，马亲王的脑洞并不是虚无缥缈的，一定有一个落点，那就是文化。他的脑洞都遵从历史，没有《史上第一混乱》那样的恶搞，只是挖掘不被正史记载的部分，融合想象力和幽默感，编排还不错的故事。这一点从他其他“名著”《殷商玛雅征服史》《三国机密》等可见一斑。</p><p>从口味来讲，马伯庸算是个标准的文人。写的书多，看的书更多，爱逛书店，专寻些冷门的书。比如之前写微博说逛书店翻到一本讲漕运、讲财政史的书，奉若至宝——也有过几百本阅历的我，听都没听过。</p><p>如果专业从文，那么讨论马亲王的文化水平，讨论他的名气和受欢迎的程度，也没什么稀奇。奇就奇在他从本科到留学再到工作，都与文字和历史无关。他学的是市场营销，工作进的单位是做电器的施耐德，在销售、商务岗位摸爬滚打近十年。从未抛弃所学专业，但在他的书里倒也完全看不出这些痕迹。</p><p>施耐德毕竟是民营外企，至少在不务正业上，马亲王比娘子关的刘前辈强了一点。至于工作上的低调与成绩上的反差，又能将将追平当年明月。</p><p>有人说马伯庸的文字缺少辨识度。这大概就是非专业作家的典型特征。但这另一重身份，与浸淫多年的理工科思维，似乎正是马亲王幽默感的来源。众所周知文人都有点酸腐和娇弱造作。这是幽默感的大敌。仔细想想但凡是身份多样的作家才有行云流水的幽默感，比如开赛车的韩寒、喂马喂羊的李娟、专业会计还会写程序的王小波……当然，妇科医生加企业CEO的冯唐不算。</p><p>马亲王还有个业余爱好是写段子，这也正是他幽默感的第一出口。在段子手横行的早年微博，他是跟“所长别开枪是我”、“天才小熊猫”、“叫兽易小星”等人混一个圈子的。可惜这两年段子风潮不再，每年的春晚段子大考也是惨不忍睹，马亲王的微博也更新见少。如果感兴趣，可以去翻翻他前几年的微博，尤其是关于儿子马小烦的部分。</p><p>但你最好期望自己不要在他书里看到那些段子，毕竟过时的段子比过时的水果还难闻。</p><p>关于马亲王，网上一直有两个梗。一个是祥瑞御免，说的是他早些年运气爆棚，朋友各种出事，自己却毫发无损，网上便传只要是他接触过的人都要倒霉。以致每次他在网上发文，评论都要齐齐刷一遍“祥瑞御免”，以免厄运缠身。另一个则是陨石遁，来自于他早年出版的一本小说，到结尾编不下去了，直接天上掉下一颗陨石，全剧终。让人直呼上当，简直要满嘴喷粪。</p><p>马亲王出道已久，长版的长篇都有十几本了。正值四十壮年的马亲王，写书似乎越来越游刃有余。这一点看最新的几本豆瓣评分即可。尤其是《长安十二时辰（上）》，都过了8.5。不过个人最推荐的，还是《显微镜下的大明》，一本讲大明时期诉讼案的纪实类书籍，评分更比前者高出0.2分。可见比起写小说，马亲王在历史上的钻研似乎更为精深一些。</p><p>最后说回《长安十二时辰》。怎么讲，此书前百分之八十我给一百分，最后结尾——我就当又被陨石轰顶了吧。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;看完了长安十二时辰，这是最近第二本让人热血沸腾的小说了（前一本是乔治马丁的《沙王》）。妹想到浓眉大眼的马亲王也
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.kuang2.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.kuang2.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>平原上的摩西</title>
    <link href="http://www.kuang2.cn/2021/05/26/%E5%B9%B3%E5%8E%9F%E4%B8%8A%E7%9A%84%E6%91%A9%E8%A5%BF/"/>
    <id>http://www.kuang2.cn/2021/05/26/平原上的摩西/</id>
    <published>2021-05-26T21:23:00.000Z</published>
    <updated>2022-04-11T02:53:32.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>听到《刺杀小说家》这部电影，我的第一印象是对原作者双雪涛感到莫名熟悉，似乎什么时候看到他的书；第二印象则是光听名字，刺杀，小说家，这个动宾结构，就很有想象力的感觉。但因为看过沧月《织梦者》的关系，仍然是抹不去的套路感。</p><p>一个因为崽子留在老家而空闲的下午，打开寂寞许久的55寸大电视，看完了杨幂和雷佳音主演的这部电影。虽说套路，也有创意和惊喜。比如主角的技能竟然是扔石子，比如小说家的重庆人身份（话说山城太适合魔幻现实主义了，参照《无名之辈》），比如四条胳膊的巨型boss带给人的震撼。最大的惊喜显然是特效和美术的部分。在故事中吃到满嘴狗屎的观众，就当自己观赏了一场银幕光影秀吧。</p><p>虽然是一种极不明显的嗅觉，但我依然能从电影里感受到一股子文学味：原书肯定比电影强。</p><p>周末跑了一趟荆州，去、回、加过夜，车程也就一个小时多点，时间并不算充裕，但也需要一点精神食粮填充百无聊赖的车程。翻阅电子书下载站，刚好看到双雪涛的短篇小说集——《猎人》。于是下载之。</p><p>第一篇就给我很惊艳的感觉：一个作家，偶然遇到一个声称要超越他的男孩，通过邮箱陆续给他寄来小说稿……当然结局是没有的。类似这种掐头去尾的短篇，之前也看过一些。但双雪涛的东西给人感觉更加玄妙，很有个人风格，但同时也带点作者是不是已经走火入魔的疑问。当然重点是文笔，长短句，读起来很有新意。类似的语感是以前没有领教过的。</p><p>在看过的有个人语感的作家里，和菜头、冯唐、李海鹏甚至郭敬明，双雪涛的文字又是一种气质。光是这一点就不会让翻开这本书的人后悔。</p><p>对比双雪涛我又想到猫腻和紫金陈，后两者刚好相反，故事一流，原小说却很难读，像中学生写的网文。果然小说也得讲点文采。</p><p>《猎人》是双雪涛比较近期的作品。翻了下豆瓣才7分出头，网上更多人推荐的是早期的集子《平原上的摩西》。摩西我知道，圣经嘛。看着这么西式的名字，虽然狐疑，依然打开手机下好了一本传入kindle。</p><p>相较之下，果然《摩西》故事更好。虽然在这本早期册子里，双雪涛的个人风格还未沉淀，充满了模仿痕迹。但写的东西更有诚意，故事更完整。全书光环主要集中在第一个中篇，也就是同名小说“平原上的摩西”。80年代的东北，悬疑犯罪，多人称叙事，结尾带点宿命感。</p><p>类似这种充满地方特色的短篇，之前还看过的是班宇和君达乐的慢先生。尤其是班宇，同样的八九十年代，同样的东北。虽然《冬泳》有诸多明星背书，时常出没于社交网站，但却是我没法看完的一本书。故事雷同的厉害，多看几篇就很腻歪（这也是大多数短篇小说的问题）；更主要的是故事很琐碎，意思不太大。双雪涛的故事性也不强，但只要文字好，读起来就有快感。</p><p>说到阅读文字的快感，作为双雪涛大半个偶像的王小波（在王小波《我的精神家园》里有一篇《我的师承》，《平原上的摩西》里同样有一篇），有句话说得好：</p><blockquote><p>所谓文学，在我看来就是：先把文章写好看了再说，别的就管他妈的。——王小波</p></blockquote><p>有那么一段时间，我对现当代文学是产生过失望的。尤其是拜读过那些在社交网站上坐拥百万粉丝的大作后（典型如张嘉佳、东东枪、雪村、李承鹏等），也不算太差，但相比老舍、汪曾祺、钱钟书那代人是远远无法望其项背的。后来有机会了解到李娟、李盆，这种感受才好转点。在知乎里搜双雪涛，看到这么一条回答：</p><blockquote><p><a href="https://www.zhihu.com/question/41212458/answer/575968593" target="_blank" rel="noopener">哪些瞬间让你对中国当代文学感到绝望？</a></p><p>《收获》《当代》《十月》《人民文学》《中国作家》《小说界》《江南》《清明》《上海文学》《北京文学》《天涯》《钟山》《芙蓉》《花城》《鸭绿江》《山西文学》《坚果》《读库》……这些文学期刊一直在出版，你不知道，只知道晋江起点纵横。不说老一辈作家，40多岁以下的，盛可以、阿乙、曹寇、张楚、张慧雯、徐则臣、路内、葛亮、双雪涛、乔叶、姚鄂梅、鲁敏、双雪涛、魏思孝、唐棣、滕肖澜、李娟、李唐、周朝军、小饭、甫跃辉、马金莲、张怡微、孙频、于一爽、石一枫、尹丽川、何袜皮、朱文颖……你不知道这人，只知道郭敬明、唐家三少。然后你说你对文学绝望了，问题你和文学有交集吗？</p></blockquote><p>才恍然世界之大。</p><p>总而言之，在书荒严重的最近，双雪涛给了我一点惊喜。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;听到《刺杀小说家》这部电影，我的第一印象是对原作者双雪涛感到莫名熟悉，似乎什么时候看到他的书；第二印象则是光听
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.kuang2.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.kuang2.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>项塔兰</title>
    <link href="http://www.kuang2.cn/2021/05/16/%E9%A1%B9%E5%A1%94%E5%85%B0/"/>
    <id>http://www.kuang2.cn/2021/05/16/项塔兰/</id>
    <published>2021-05-16T14:23:00.000Z</published>
    <updated>2022-04-11T02:53:32.360Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>最近印度疫情爆炸，才发现对这个国家认知粗浅。看过全球大历史，看过欧洲革命史、美国种族史、日本风俗史，倒还从没了解过印度相关的历史。</p><p>于是在豆瓣搜印度的关键词，排在第一位的就是这本《项塔兰》，似乎是本小说。原本只是想找一本类似《别跟我说你懂日本》这样全方位介绍当代印度的书。但瞟到《项塔兰》高度9.0的评分——算了，就它了。</p><p>一个抢劫、坐牢、越狱，然后逃到印度孟买的男人，从四处旅游，到被抢劫一空，住入贫民窟，凭借临时训练得来的半吊子医术当起赤脚医生，最后混进印度黑帮……传奇般的故事，竟然是作者的自传。这样一看就更传奇了。</p><p>故事精彩纷呈，整体文风给我的感觉很像钱德勒《漫长的告别》。同样是独行客、异乡、犯罪份子的黑色背景。但又无处不透露出人文关怀和哲学辩思。这一点又像极了海斯勒的纪实文学。总的来说，作者，包括故事的主角，算是个好人，虽然也抽大麻、参与过抢劫并且坐过监狱，但只要秉持良善，三观端正，这书就值得推荐。</p><p>之前在媒体报道中了解的印度，是一个种姓分隔但飞速发展，女权低下又年轻气盛，做过殖民地却提前民主，互联网飞速发展然而贫民窟也不遑多让的西亚大国。最近看了些讲印度代孕、印度为何抗疫失败，以及印度为什么发展不起来的文章，认识稍有深入，以往对班加罗尔的向往也减少许多。</p><p>第一本项塔兰结束之后，孟买的贫民窟是给我留下的第一印象。几万人搭棚而居的临时聚集地，每天开放一小时的水源，一家六七口人蜗居几平米的茅屋……作为本国农村长大的准底层人士，穷人家的住所我也见过不少，但依然比不过这几千公里外的异乡穷壤。</p><p>穷归属于痛苦，但绝非原罪。我妈妈那代人也经历过饥寒交迫的贫穷，但那已成过往。在中国宣告共和国成立的两年之前，印度即已实现独立。然而就算中国经受几十年的国际排挤、走过若干年的弯路，如今依然可以站在更高的位置俯视印度，并对那些贫民窟发生的事生发怜悯之情。</p><p>当然，深处水深火热的人们不会觉得自己多么煎熬，就好像七八十年代中国人民和美国人民相互的嘲讽和同情。在作者笔下，孟买的贫民窟成为他为之依赖的家，一起住着像普巴拉克这样可爱而单纯的朋友们。就算臭气熏天，家徒四壁，也已成为他亲切感与安全感的来源。他深深融入其中。</p><p>这让我想到卢安克，那个在广西深山里志愿支教，一待就是数十年的德国小伙。欧美教育下成长的青年，似乎有很能适应贫瘠的能力。不像中国人穷怕了，无法忍受任何形式的匮乏。除了抗住穷的压力，卢安克还能忍受意义的压力。他不承诺学习成绩，也从未担心教过的孩子是否成才。</p><p>而在项塔兰中，林巴巴能住酒店也能住贫民窟，行医从不收费，赚够一星期的生活费就休息一星期，物质享受似乎与他无缘。行事也毫无目的，普巴拉克邀请他去村里住半年，他欣然同往；当有了一定的谋生能力，可以搬去更好的居所，他也乐于继续待在贫民窟里。全部财产就那几件衣物、洗漱用品和邻居送的桌椅板凳。</p><p>一本好书就是一扇观赏未知世界的大门。管窥印度，让你仿佛在孟买街头散步，这就是《项塔兰》。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;最近印度疫情爆炸，才发现对这个国家认知粗浅。看过全球大历史，看过欧洲革命史、美国种族史、日本风俗史，倒还从没了
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.kuang2.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.kuang2.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>职业病们</title>
    <link href="http://www.kuang2.cn/2021/05/13/%E8%81%8C%E4%B8%9A%E7%97%85/"/>
    <id>http://www.kuang2.cn/2021/05/13/职业病/</id>
    <published>2021-05-13T22:23:00.000Z</published>
    <updated>2022-04-11T02:53:32.360Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>经常听到或看到别人说，三十岁之前身体都是生龙活虎，三十岁以后职业病如山倒。</p><p>对我而言，还未及毕业，在那工作的头三个月，就隐隐出现职业病的征兆。</p><p>第一个早早就位的是干眼症。</p><p>在第一份工作，某N流网站的鸡肋运营岗上。8*6小时的高强度面对显示器，时节刚好在湿度尚未回升的冬春之交。忽然就开始觉得眼睛说不上的不适，体感并没有很痛苦，但严重影响工作效率。有时候是右眼，更多是左眼。不适感袭来时，常常持续一整天，很少会草草收场。只能闭着眼睛，或者用带温度的手掌捂一下。</p><p>网上寻医问药，被某同学安利蒸汽眼罩，又逐渐了解到眼部按摩仪、吃蓝莓或芒果、甚至是人工泪液等方案。也尝试过一些，但无法彻底根治，才意识到自己命途多舛，身体慢性病清单又多了一条。</p><p>陪伴一两年后，到15年的冬天愈发严重，出现轻微抽搐的症状。终于下定决心去看眼科，还好不算严重，只是破天荒地在太阳穴挨了一针。药名忘了，记忆深刻的是药物适应症写着，针对中老年人常见的眼角抽搐……原来是我这从小不抗造的体质，已经提前步入老年。</p><p>同样因为这职业而带来的，也同样因这“老年人”体质而出现的，是手腕痛（肌鞘炎）。</p><p>针对病痛部位，可以想见是握持鼠标时间太长（姿势不对？）。痛苦程度强于干眼症，但也不剧烈，只是持续性的酸痛，严重的时候，躺着睡觉时都找不到一个舒服的放手姿势。也试过腕托、工程学鼠标（相对便宜的垂直鼠标、极其冷门的台式机专用触控板），以及苦练各种系统快捷键，装浏览器快捷键插件（Vimium）。</p><p>更多时候是感到困惑，深感命运之不公。周遭一圈也没看到几个有类似病痛的同僚，不明白为啥这么冷门的疾病能独宠我一人。</p><p>久病成良医。这病给我带来的影响是，极挑鼠标，目前只有一款雷蛇的游戏鼠标能供我长时间使用，可惜已经停产了。再买鼠标得考虑高度、大小、按键的硬软（？）。更大的影响也是我最有效的解决之道：学会了左手用鼠标。在工作强度较大时，基本都是右手半天、左手半天。</p><p>此外，困扰了大多数IT业者的腰痛，也如期而遇。</p><p>腰痛也是酸痛的一种，但来的凶，来的久。严重之时，像屁股着火，没法坐。某次去外地驻场办公，在逼仄的临时工位、硬邦邦的椅子上，腰痛袭来，一天得站起来无数次，还没法像其他上了年纪的同僚一样去窗边楼道吞云吐雾，只能靠频繁往厕所跑转移注意力，没屎没尿也得躲在隔间里，顺便做深蹲和下腰。</p><p>其实据说缓解腰痛并不难，比如运动，下腰，或者趴床上做“大雁飞”。懒惰如我，当然坚持不到每天运动。还好最近一年都是居家远程办公，腰痛厉害的时候干脆趴着。</p><p>同龄人中，我应该是最早开始站立办公的吧。在自己房间几平米的空间里，也没什么高科技手段，买不起动辄几千块的电动升降桌，直接多准备一套显示器、键盘和鼠标，拿一个床上电脑桌架起来，然后连上HDMI转换器，想坐或者想站了，一键切换。</p><p>俗话说方法总比困难多。这话在我上大学尝试起隔音耳塞睡觉时，第一次深有体会并深信不疑。后来年岁变迁，又被我渐渐淡忘，直到在第一份工作被干眼症困扰，找某R同学诉苦，求问这转行的决定是否明智时，在他的忠言中，这话才重新在脑海浮现。依稀记得他说，困难总比方法多，凡事都有解决的办法。病了就去治，痛了就吃药。不要忘了初衷。</p><p>因为这初衷，而不是因为这些拦路虎般的职业病们，我走到现在，并准备继续往前走去。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;经常听到或看到别人说，三十岁之前身体都是生龙活虎，三十岁以后职业病如山倒。&lt;/p&gt;&lt;p&gt;对我而言，还未及毕业，
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.kuang2.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="杂感" scheme="http://www.kuang2.cn/tags/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>react hook不常用方法学习</title>
    <link href="http://www.kuang2.cn/2021/04/30/react%20hook%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.kuang2.cn/2021/04/30/react hook不常用方法学习/</id>
    <published>2021-04-30T20:58:00.000Z</published>
    <updated>2022-04-11T02:53:32.348Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>参考文章：<a href="https://www.58h.com.cn/a/%E3%80%90ReactDeZuoBiMoShi%E3%80%91LiJieUseReducerDeYouShiHeGaoJiYongFa.html" target="_blank" rel="noopener">【React的作弊模式】理解useReducer的优势和高级用法</a></p><p>基础用法：本质上就是将多个useState合并处理。将分开的setData改用dispatch传递到自定义的reducer函数中，使用if判断更新到合并的state对象中</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用useState</span></span><br><span class="line"><span class="keyword">const</span> [data, setData] = useState(<span class="string">''</span>);</span><br><span class="line"><span class="keyword">const</span> [address, changeAddress] = useState(<span class="string">'初始地址'</span>)；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用useReducer</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    data: <span class="string">''</span>,</span><br><span class="line">    address: <span class="string">'初始地址'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(action.type == <span class="string">'setData'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;...state, <span class="attr">data</span>: action.payload&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(action.type == <span class="string">'changeAddress'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;...state, <span class="attr">address</span>: action.payload&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(initialState, reducer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改data或addresss</span></span><br><span class="line">dispatch(&#123;<span class="attr">type</span>: <span class="string">'setData'</span>, <span class="attr">payload</span>: <span class="string">'新data'</span>&#125;)</span><br></pre></td></tr></table></figure><p>当然，最适合的使用场景是表单中，同时把payload的值改为formData对象，则不必再写多个if else的判断</p><p>文章中另有高级用法，待尝试</p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>基础用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useMemo, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> couterRef = useRef();</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`The value is <span class="subst">$&#123;count&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(couterRef.current); <span class="comment">// 引用dom</span></span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button ref=&#123;couterRef&#125; onClick=&#123;() =&gt; &#123;setCount(count + <span class="number">1</span>)&#125;&#125;&gt;Count: &#123;count&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>useRef与createRef的区别，参考： <a href="https://zhuanlan.zhihu.com/p/105276393" target="_blank" rel="noopener">你不知道的 useRef</a></p><blockquote><p>useRef 在 react hook 中的作用, 正如官网说的, 它像一个变量, 类似于 this , 它就像一个盒子, 你可以存放任何东西. <strong>createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用。</strong></p></blockquote><p>高级用法：“跨渲染周期”保存数据</p><p>作为不影响渲染，同时又能缓存数据的变量使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useMemo, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> timerID = useRef();</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    timerID.current = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>); </span><br><span class="line">  &#125;, []);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(count &gt; <span class="number">10</span>)&#123;</span><br><span class="line">          clearInterval(timerID.current);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button ref=&#123;couterRef&#125; onClick=&#123;() =&gt; &#123;setCount(count + <span class="number">1</span>)&#125;&#125;&gt;Count: &#123;count&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>需要厘清useMemo和React.memo的区别</p><blockquote><p>React.memo本质是高阶组件（HOC），与 PureComponent 很相似，但是是专门给 Function Component 提供的。可以传递一个函数参数来判断是否render（类似shouldComponentUpdate ，但逻辑相反）（不传则进行浅比较）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* render using props */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  return true if passing nextProps to render would return</span></span><br><span class="line"><span class="comment">  the same result as passing prevProps to render,</span></span><br><span class="line"><span class="comment">  otherwise return false。返回 true 时，不会触发 render</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure><blockquote><p>useMemo用来减少组件内的特定函数方法的重复执行</p><p>如果你傳給 <code>useMemo</code> 的 function 裡面運算很繁重，例如可能要 map 一組很大的陣列，這時候可能就很值得用 <code>useMemo</code> 把運算結果暫記起來下次用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume this returns an Array of 3000 records</span></span><br><span class="line"><span class="keyword">const</span> menuItemRows = useMemo(</span><br><span class="line">    () =&gt; thousandsOfMenuItems.map(<span class="function"><span class="params">menuItem</span> =&gt;</span> (</span><br><span class="line">        &lt;MenuItemRow key=&#123;menuItem.uuid&#125; name=&#123;menuItem.name&#125; /&gt;</span><br><span class="line">    )),</span><br><span class="line">    [thousandsOfMenuItems]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果不传递第二个依赖项，则每次render都会执行</p><p><a href="https://medium.com/ichef/%E4%BB%80%E9%BA%BC%E6%99%82%E5%80%99%E8%A9%B2%E4%BD%BF%E7%94%A8-usememo-%E8%B7%9F-usecallback-a3c1cd0eb520" target="_blank" rel="noopener">什麼時候該使用 useMemo 跟 useCallback</a> 这篇文章对这两个方法有比较准确的描述：</p><blockquote><p>React 引入新的 Hooks 系統後，有兩個 Hook 可以拿來做快取加速用途，分別是記住 return value 的 <code>useMemo</code> 跟記住 function instance 的 <code>useCallback</code> 。但是什麼時候該用到這兩組 Hook 來幫你的 React app 做加速呢？</p><p><code>useMemo</code> → 遇到複雜耗時計算時使用</p><p><code>useCallback</code> → 大部分不用，僅在搭配 PureComponent 等、或是提供多個 <code>useEffect</code> 時使用</p></blockquote><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><blockquote><p>useMemo用来缓存函数计算值，useCallback则用于缓存函数本身</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> [val, setVal] = useState(<span class="string">''</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> callback = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;, [count]);</span><br><span class="line">    <span class="keyword">set</span>.add(callback);</span><br><span class="line"> </span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h4&gt;&#123;count&#125;&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h4&gt;&#123;set.size&#125;&lt;/</span>h4&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setVal(event.target.value)&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例子，每次修改count，set.size就会+1，这说明useCallback依赖变量count，count变更时会返回新的函数；而val变更时，set.size不会变，说明返回的是缓存的旧版本函数。</p><p>推荐阅读：<a href="https://jancat.github.io/post/2019/translation-usememo-and-usecallback/" target="_blank" rel="noopener">什么时候使用 useMemo 和 useCallback</a></p><blockquote><p>最后，我想说，每个抽象(和性能优化)都是有代价的。应用 <a href="https://kentcdodds.com/blog/aha-programming" target="_blank" rel="noopener">AHA 编程原则</a>，直到确实需要抽象或优化时才去做，这样可以避免承担成本而不会获得收益的情况。</p><p>具体来说，<code>useCallback</code> 和 <code>useMemo</code>的成本是：对于你的同事来说，你使代码更复杂了；你可能在依赖项数组中犯了一个错误，并且你可能通过调用内置的 hook、并防止依赖项和 memoized 值被垃圾收集，而使性能变差。如果你获得了必要的性能收益，那么这些成本都是值得承担的，但<strong>最好先测量一下</strong>。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;useReducer&quot;&gt;&lt;a href=&quot;#useReducer&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="技术" scheme="http://www.kuang2.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS JS基础 React" scheme="http://www.kuang2.cn/tags/JS-JS%E5%9F%BA%E7%A1%80-React/"/>
    
  </entry>
  
  <entry>
    <title>我了解的日本</title>
    <link href="http://www.kuang2.cn/2021/04/27/%E6%88%91%E4%BA%86%E8%A7%A3%E7%9A%84%E6%97%A5%E6%9C%AC/"/>
    <id>http://www.kuang2.cn/2021/04/27/我了解的日本/</id>
    <published>2021-04-27T22:23:00.000Z</published>
    <updated>2022-04-11T02:53:32.356Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">文章已加密，输入密码解锁：</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      文章已加密
    
    </summary>
    
      <category term="随笔" scheme="http://www.kuang2.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="杂感" scheme="http://www.kuang2.cn/tags/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>vue3.0学习笔记</title>
    <link href="http://www.kuang2.cn/2021/04/17/vue3.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.kuang2.cn/2021/04/17/vue3.0学习笔记/</id>
    <published>2021-04-17T22:58:00.000Z</published>
    <updated>2022-04-11T02:53:32.348Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><h3 id="vue和react的区别"><a href="#vue和react的区别" class="headerlink" title="vue和react的区别"></a>vue和react的区别</h3><p>1.vue专有语法：.vue模板文件data、methods、computed计算属性、watch侦听器、setup（3.0新增）</p><p>2.vue指令(以v开头)​ v-on,v-click,v-if 等等；</p><p>3.vue属性绑定需要指令+字符串的形式，如:class=”isActive:activeClass”，react直接使用两层大括号插值</p><p>4.react组件的状态必须使用setState，vue直接this.xxx</p><p>5.vue和react的生命周期略有不同</p><h3 id="重点知识点"><a href="#重点知识点" class="headerlink" title="重点知识点"></a>重点知识点</h3><p>1.v-is</p><p>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。</p><p>这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post-row</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个自定义组件 <code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。我们可以使用特殊的 <code>v-is</code> 指令作为一个变通的办法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-is</span>=<span class="string">"'blog-post-row'"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-is包含的是单引号包含的JavaScript字符串文本，指向一个组件</p><p>2.provide / inject</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在父组件中：使用原始值</span></span><br><span class="line">provide: &#123;</span><br><span class="line">    user: <span class="string">'John Doe'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者 使用data </span></span><br><span class="line">provide() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      todoLength: <span class="keyword">this</span>.todos.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在子组件中</span></span><br><span class="line">inject: [<span class="string">'user'</span>],</span><br><span class="line"><span class="comment">// 则在子组件中即可使用此数据：this.user</span></span><br></pre></td></tr></table></figure><p>3.模板引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;div ref=<span class="string">"root"</span>&gt;This is a root element&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      <span class="keyword">const</span> root = ref(<span class="literal">null</span>)</span><br><span class="line">      onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// DOM元素将在初始渲染后分配给ref</span></span><br><span class="line">        <span class="built_in">console</span>.log(root.value) <span class="comment">// &lt;div&gt;这是根元素&lt;/div&gt;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        root</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>4.自定义指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">directives: &#123;</span><br><span class="line">  myfocus: &#123;</span><br><span class="line">    mounted(el) &#123;</span><br><span class="line">      el.focus();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&lt;input v-myfocus&gt;</span><br></pre></td></tr></table></figure><p>作用：选项中derectives下的myfocus与模板中的v-myfocus绑定，声明了v-myfocus的节点，会在mounted生命周期执行编写的事件函数，参数是对应节点</p><h3 id="vue人性化的部分"><a href="#vue人性化的部分" class="headerlink" title="vue人性化的部分"></a>vue人性化的部分</h3><p>1.事件修饰符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.插槽</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在父组件中</span></span><br><span class="line">&lt;todo-button&gt;</span><br><span class="line">  Add todo</span><br><span class="line">&lt;<span class="regexp">/todo-button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/在子组件中</span></span><br><span class="line"><span class="regexp">&lt;button class="btn-primary"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;slot&gt;&lt;/</span>slot&gt;</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>3.非 Prop 的 Attribute直接成为子组件（单个根元素）dom的attribute</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在父组件中</span></span><br><span class="line">&lt;todo-button <span class="class"><span class="keyword">class</span></span>=<span class="string">'active'</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在子组件中：根组件是单一dom组件</span></span><br><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn-primary"</span>&gt;</span><br><span class="line">  &lt;slot&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>4.:style中自动添加前缀</p><p>5.强制增加响应式： reactive, ref，toRef，或强制只读：readonly</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref, reactive&#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">        <span class="keyword">let</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">let</span> num2 = ref(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">let</span> num3 = reactive(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(num1); <span class="comment">// 数值类型10</span></span><br><span class="line">        <span class="built_in">console</span>.log(num2); <span class="comment">// 对象 &#123;value: 10&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(num3); <span class="comment">// 数值类型100</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            num1,</span><br><span class="line">            num2,</span><br><span class="line">            num3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><blockquote><p>ref-创建出来的数据和以前无关(复制)<br>toRef-创建出来的数据和以前的有关(引用)<br>ref-数据变化会自动更新界面<br>toRef-数据变化不会自动更新界面</p></blockquote><p>6.自定义指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">app.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素挂载到 DOM 中时……</span></span><br><span class="line">  mounted(el) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&lt;input v-focus /&gt;</span><br></pre></td></tr></table></figure><p>7.teleport 在指定位置渲染组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">'modal-button'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @click="modalOpen = true"&gt;</span></span><br><span class="line"><span class="string">        Open full screen modal! (With teleport!)</span></span><br><span class="line"><span class="string">    &lt;/button&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;teleport to="body"&gt; // 关键代码</span></span><br><span class="line"><span class="string">      &lt;div v-if="modalOpen" class="modal"&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">          I'm a teleported modal! </span></span><br><span class="line"><span class="string">          (My parent is "body")</span></span><br><span class="line"><span class="string">          &lt;button @click="modalOpen = false"&gt;</span></span><br><span class="line"><span class="string">            Close</span></span><br><span class="line"><span class="string">          &lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/teleport&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      modalOpen: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>8.使用渲染函数替代模板，自定义tagName</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createApp, h &#125; = Vue</span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br><span class="line">app.component(<span class="string">'anchored-heading'</span>, &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> h(</span><br><span class="line">      <span class="string">'h'</span> + <span class="keyword">this</span>.level, <span class="comment">// 自定义 tag name</span></span><br><span class="line">      &#123;&#125;, <span class="comment">// props/attributes</span></span><br><span class="line">      <span class="keyword">this</span>.$slots.default() <span class="comment">// array of children 此处表示插槽内容，即模板中的&lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>创建虚拟DOM的方法：createNodeDescription方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">h(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function | null&#125; tag</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、一个组件、一个异步组件，或者 null。</span></span><br><span class="line">  <span class="comment">// 使用 null 将会渲染一个注释。</span></span><br><span class="line">  <span class="comment">// 必需的。</span></span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125; props</span></span><br><span class="line">  <span class="comment">// 与 attribute、prop 和事件相对应的对象。事件比如：onClick，修饰符则使用驼峰拼接：onClickCapture</span></span><br><span class="line">  <span class="comment">// 我们会在模板中使用。</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array | Object&#125; children</span></span><br><span class="line">  <span class="comment">// 子 VNodes, 使用 `h()` 构建,</span></span><br><span class="line">  <span class="comment">// 或使用字符串获取 "文本 Vnode" 或者</span></span><br><span class="line">  <span class="comment">// 有插槽的对象。使用插槽：this.$slots.default()，每个插槽都是一个 VNode 数组</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">'Some text comes first.'</span>,</span><br><span class="line">    h(<span class="string">'h1'</span>, <span class="string">'A headline'</span>),</span><br><span class="line">    h(MyComponent, &#123;</span><br><span class="line">      someProp: <span class="string">'foobar'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;vue和react的区别&quot;&gt;&lt;a href=&quot;#vue和react的区别&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="技术" scheme="http://www.kuang2.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS JS基础" scheme="http://www.kuang2.cn/tags/JS-JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>乱时候，穷时候</title>
    <link href="http://www.kuang2.cn/2021/04/12/%E4%B9%B1%E6%97%B6%E5%80%99%EF%BC%8C%E7%A9%B7%E6%97%B6%E5%80%99/"/>
    <id>http://www.kuang2.cn/2021/04/12/乱时候，穷时候/</id>
    <published>2021-04-12T20:12:00.000Z</published>
    <updated>2022-04-11T02:53:32.348Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>我爷爷也算个文化人。在我小学的时候，他的爱好就是听收音机拆谜语、对对子，家里也常有些书刊杂志。最近些年，可能视力减退，人也惰了，每天多半以电视度日，我常想，或许应该建议他去写写回忆录之类的，写的人锻炼了脑力，看的人，比如我，也确实想一览他们那一辈的岁月。但一直没提出口，如今他都七十出头了，身体大不如前，这话似乎过了时机。</p><p>前几天整理印象笔记，看到某个时期记的备读书目，逐一搜索下载，好像就一本《乱时候，穷时候》能看一看。于是这次出差，第一天就打开了看。网上搜索来历和作者，大吃一惊，居然是一位六十多岁学写字，七十五岁写书的奶奶写的回忆录。这不就是我期待的书么。</p><p>很久没有同时抱着期待和强烈的兴趣读书了。而这本书也确实没辜负豆瓣8.0的评分，朴实、好看、引人入胜。虽然只是回忆录，却是赤裸裸的旧现实，让人难以释卷的好故事。</p><p>印象最深的是三个故事。</p><p>第一个讲姜淑梅和他女儿。</p><p>她怀女儿时，已经有三个儿子了。因为孕感强烈，她跟丈夫说这个一定是个闺女，以为丈夫会跟她一样高兴。没想到丈夫生气了，逼着她去流产。她每天孕吐得难受，丈夫又天天在那摆臭脸，实在受不了了，某天下午独自跑去医院。医生跟她说，已经四个月了，再做有风险。今天早上刚死了一个。她说，我不怕死，死了也没人哭。医生拗不过，说那你等明天手术大夫在的时候来吧。</p><p>第二天，她叫上丈夫一起。丈夫起初不肯，觉得是个小手术，一个人去就行了。她说，医生说了，四个月做手术有生命危险，你非要做，就去给我收尸吧。丈夫听了这话，把她拦了下来，再没提过这话。</p><p>闺女健健康康出生了，这回轮到爷爷奶奶不高兴了，总是拉长个脸。刚出满月，婆婆就叫她去砖厂推车。公公倒没那么狠，跟婆婆说，一千多斤的车子，你倒是自己去推。</p><p>然而她上班以后，每天回家依然是干不完的活。闺女躺了八个月，爷爷奶奶谁也不抱。三弟结婚了，弟妹才给抱起来。弟妹说，你们这啥人家啊，孩子八个月了还不抱，啥时候能会走啊。到了一岁半，女儿才会走。</p><p>一九九一年，闺女得了一个海内外散文比赛一等奖，去南京领的奖。这时候，她才终于扬眉吐气了一番。</p><p>第二个故事讲裹脚。</p><p>那时候她还小，大哥在外边上大学，来信就说，不要给小妹裹脚，别让小妹受那种委屈。娘听了大哥的话。</p><p>别人家的闺女，六岁就开始裹脚了，讲究点的有钱人家，两三岁就把脚裹上了。</p><p>如果哪家新媳妇脚大，娶进门就要受气。时家媳妇因为脚大，丈夫看不上她，也不搭理她。去厨房吃饭故意往她脚上踩，她也不敢吱声。时家新买的小鸭子挤在门口晒太阳，新媳妇没看见，一脚迈出去，踩死了两鸭子。她自己害臊，上吊死了。</p><p>还有一家也是娶了大脚媳妇，夫妻感情本来很好。但笑话媳妇的人太多，丈夫受不了。特意去了一趟城里，买了红伤药。回到家给媳妇灌上迷糊药，等她迷糊过去了，把脚心的肉用刀子挖掉，再上上药。媳妇半夜醒过来，疼得死去活来。以后再没出过门。</p><p>裹脚的女人，大多数都不太能走路。她母亲年轻时候最犯愁的就是秋天拾棉花，拾一下午，回来还得做饭。两只脚又疼又热又难受，没处放，连腿都难受。晚饭做好了，脚疼得吃不下去。</p><p>解放以后，上面来了指示，宣传要放脚。一听说“放脚的来了”，那些大闺女小媳妇吓得到处藏。后来开了几次妇女会，大家才一个个把脚放了。几年以后，大家都说，这是毛主席做的大好事。</p><p>第三个故事讲她儿子出疹子。</p><p>那时候她刚刚跑到黑龙江投奔丈夫。住在家属宿舍里。条件艰苦的十几家人，一起挤五间土平房，没门没窗，连个暖瓶都没有。</p><p>刚开一个月工资，儿子就病了。同时期，宿舍里共有七个孩子出疹子。</p><p>她跟其他妈妈千叮万嘱，孩子出疹子怕风、畏寒，要多喝热水。可谁都没听她的。刘哥家老来得子，生了个女儿又生了个儿子，儿子刚六岁；丁哥家连生了三个女儿后得了个男孩，虎头虎脑的让人喜欢，也才八岁。两孩子总一起玩，都发了高烧。刘嫂和丁嫂也都是盲流过来的，想多挣点钱，怕耽误工夫，就打回一缸开水，放了些饼干，跟他俩说，渴了喝水，饿了吃饼干，然后上班去了。两孩子吹着过堂风，想喝水水也凉了。才八九天，两个孩子都死了。</p><p>她自己则第一时间就请了假，缝了布帐子挡风。不管白天黑夜，儿子想喝水，她都会点着三根苇子，把茶缸里的凉开水烧热再给孩子喝。</p><p>儿子睡着的时候，她去隔壁看左嫂同样出疹子的孩子。那小男孩才五岁，嘴唇和眼圈都黑了，左嫂还忙着给人家加工鞋底子呢。等把人叫回来，把孩子送去医院，孩子已经死了。</p><p>小于家更惨，五天死了姐俩，姐姐四岁，妹妹两岁。孩子妈妈啥也没干，孩子出疹子发高烧，她就给孩子凉开水喝。孩子没了，两口子哭了大半个月，领了工资就走了。</p><p>家属宿舍十三个出疹子的孩子，除了她儿子，其余的都死了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;我爷爷也算个文化人。在我小学的时候，他的爱好就是听收音机拆谜语、对对子，家里也常有些书刊杂志。最近些年，可能视
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.kuang2.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.kuang2.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《高性能JavaScript》tips</title>
    <link href="http://www.kuang2.cn/2021/03/24/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8Btips/"/>
    <id>http://www.kuang2.cn/2021/03/24/《高性能JavaScript》tips/</id>
    <published>2021-03-24T22:45:00.000Z</published>
    <updated>2022-04-11T02:53:32.348Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><h3 id="1-重绘（repaints）和重排（reflows）"><a href="#1-重绘（repaints）和重排（reflows）" class="headerlink" title="1.重绘（repaints）和重排（reflows）"></a>1.重绘（repaints）和重排（reflows）</h3><p>元素宽、高、边框等影响“占地面积”的布局改变时，会产生重排，而改变颜色、背景等只会触发重绘而不会产生重排</p><p>如何减少重排和重绘：</p><p>1.不要在设置元素属性后立即对属性求值，求值会导致浏览器强制马上重排或重绘界面UI</p><p>2.尽量一次性修改元素样式，比如使用className</p><p>3.考虑将元素先脱离文档（隐藏、拷贝元素到fragment等）</p><p>4.缓存布局信息（比如对元素offsetTop递增时，使用变量递增而不是offsetTop+1这样的递增）</p><h3 id="2-展开循环以减少迭代次数"><a href="#2-展开循环以减少迭代次数" class="headerlink" title="2.展开循环以减少迭代次数"></a>2.展开循环以减少迭代次数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>];</span><br><span class="line"><span class="keyword">var</span> iterations = <span class="built_in">Math</span>.ceil(items.length / <span class="number">8</span>), <span class="comment">// Match.ceil 向上取整  比如length=12，则此时等于2 即执行两次循环</span></span><br><span class="line">    startAt = items.length / <span class="number">8</span>, <span class="comment">// 取余数，比如length=12，则此时等于4</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFunc</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"e="</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'do, '</span>, startAt, i); <span class="comment">// 第一次 4 ，0 第二次 0 4</span></span><br><span class="line">    <span class="keyword">switch</span> (startAt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: processFunc(items[i++]); <span class="comment">// 没有break语句，在命中某个case之后，后面的case会全部执行</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: processFunc(items[i++]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: processFunc(items[i++]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: processFunc(items[i++]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: processFunc(items[i++]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: processFunc(items[i++]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: processFunc(items[i++]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: processFunc(items[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    startAt = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (--iterations);</span><br></pre></td></tr></table></figure><h3 id="3-任务分片"><a href="#3-任务分片" class="headerlink" title="3.任务分片"></a>3.任务分片</h3><p>对于不需求立即获取结果的任务，可以使用任务分片，通过定时器分片处理此任务，避免长时间占用线程导致界面卡顿（因为js线程一直占用，无法更新UI，导致看上去界面没有反应）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveDocument</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    openDocument(id);</span><br><span class="line">    whiteText(id);</span><br><span class="line">    closeDocument(id);</span><br><span class="line">    updateUI(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改造</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveDocument</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tasks = [openDocument, whiteText, closeDocument, updateUI];</span><br><span class="line">    <span class="keyword">var</span> curDo = tasks.shift(); <span class="comment">// 取数组中的第一项，作为当前任务</span></span><br><span class="line">    curDo(id);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(task.length)&#123;</span><br><span class="line">            saveDocument(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">25</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 针对较大的数组，使用时间限制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timedProcessArray</span>(<span class="params">items, process, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> todo = items.shift();</span><br><span class="line">    <span class="keyword">var</span> startTime =  curTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> curTime = startTime;</span><br><span class="line">    <span class="keyword">while</span>((<span class="keyword">new</span> <span class="built_in">Date</span>()) - startTime&lt;<span class="number">50</span> &amp;&amp; items.length)&#123;</span><br><span class="line">        process(todo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(items.length)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            timedProcessArray(items, process, callback)</span><br><span class="line">        &#125;, <span class="number">50</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        callback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h3 id=&quot;1-重绘（repaints）和重排（reflows）&quot;&gt;&lt;a href=&quot;#1-重绘（repaint
      
    
    </summary>
    
      <category term="技术" scheme="http://www.kuang2.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS JS基础" scheme="http://www.kuang2.cn/tags/JS-JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>微博过后是抖音</title>
    <link href="http://www.kuang2.cn/2021/03/17/%E5%BE%AE%E5%8D%9A%E8%BF%87%E5%90%8E%E6%98%AF%E6%8A%96%E9%9F%B3/"/>
    <id>http://www.kuang2.cn/2021/03/17/微博过后是抖音/</id>
    <published>2021-03-17T22:01:00.000Z</published>
    <updated>2022-04-11T02:53:32.356Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>最近一两年，因为工作、年长的压力、娃的磨人，空闲时间愈少，但是在手机上某个app的时间却格外多了起来。</p><p>不用费力猜了，直接摊牌吧，就是抖音。</p><p>就像这几年也很难有空去看完整的电视电影，只能趁着吃饭的空余点开《吐槽某会》《王牌某王牌》一样。可以随时被打断、不费脑筋、瞬即就能带来欢声笑语和某种精神满足的短视频，成了每日精神外卖的一大来源。就像泡面，没啥营养，但闻起来够香，饱腹效率极高。那么你就很难不在厨房里屯上几包。</p><p>当然，在短视频风气愈来愈盛的当下，依然有很多身边人对其嗤之以鼻。我身边的一些人宣称从来不看抖音，另一些人则视抖音如冠状病毒，看到我手机上的抖动音符图标，会不自觉嘴角后抿白眼狂翻。他们自己偶尔会装上也是为了薅点羊毛，奖金到账马上翻脸卸载，生怕app污染了手机，但似乎并不怕金钱污染了银行卡。</p><p>记得疫情刚开始的时候，有一张照片流传甚广：方舱医院的病床上，一位隔离病人正躺着看历史学家福山的《政治秩序的起源》。很难想象，如果看书的这哥们不是捧着本名著，而是捧着手机刷短视频，照片的命运会如何？必定无人问津，连谈资都算不上。而如果短视频里刚好还是个跳着舞穿着低胸装的美女，那恐怕还得打上几格马赛克。</p><p>一个app跟某种上不了台面的品味挂上了钩，肯定不能算是app的错。说到底它只是个内容平台，一个带点科技含量的虚拟容器。app的另一边是人，拍的人、看的人，也就是大家身边的每个人。格调、品味如何，不过是众生百态的反射。人民群众喜闻乐见的，一定是郭德纲的通俗，而非帕瓦罗蒂的傲慢。一些不喜欢抖音的人想要的，或许豆瓣能给、知乎能给、丁香园能给，似乎用不着再找短视频索取。短视频或许也能给，但这需要点耐心去检索，去等待风向的改变。这方面B站做出了好的榜样。</p><p>娱乐需要被分高下吗？我觉得内容可以做个区分，形式上则不必。把短视频上万个点赞的美女跳舞视频，拿来和奥斯卡获奖短片相比，后者一定能在内涵、格调上秒杀前者。但把看书放在比刷短视频更高的位置的人，恐怕也拿不准书皮封面上是不是写着《素女经》或者《富婆爱上我》之类呢。至于所谓国粹京剧者，也免不了有《大劈棺》《纺棉花》等等不堪回首的过往。</p><p>还有一种说法，认为这是娱乐和艺术欣赏（或者学习）的区别。看《大劈棺》的和看《富婆爱上我》的一定是同一类人，同样看《贵妃醉酒》和看《政治秩序的起源》又是另一种人。这样说起来，娱乐好像成了一种错误。但也很难这样下定义。娱乐只是娱乐。不能肩负其他重任，也不必掺杂其他内涵。你不能指望在《吐槽大会》里了解脱口秀的起源、变种，以及和相声的学术性辩证关系。自然也不可能在B站的学习视频里等着谁给你讲上几个柏拉图的段子。</p><p>一个显而易见的事实是，群众需要娱乐。蝇营狗苟一世为人，压力就像入梅的雨水，躲之不及又坠落不停。压力有来自上一辈的，有来自下一代的；有来自生活的，有来自经济的；有来自老婆的，有来自老板的。娱乐是个挺好的躲雨屋檐、压力释放窗口。有的人会选择抽烟喝酒，可惜有点伤肝伤肺；有的人喜欢买皮肤收快递，结果却是把精神压力转化成经济压力；还有些人选择刷刷抖音，而这只是费点时间。至于时间嘛，挤一挤的话人人都有不少。</p><p>一些能享受到高级娱乐形式的人们，总是会轻视并且低估不那么高级娱乐的市场需求。抖音最让我感动的一点，是当我给大字不识的奶奶配上一台几百块的红米智能机的那天，她几分钟时间就学会了刷抖音。操作真的很简单，往上滑，往下滑，喜欢就双击。不必识字也不必动脑，从此可以打发很多在门前枯坐的时间。</p><p style="text-align:center"><img src="/images/玩抖音的郑大婆.jpg" style="width:35%" title="会站的大头凡" alt="会站的大头凡"></p><p>再说娱乐存在的形态也一直在变迁。2021年我们刷着抖音逛着微博，几年之前我们在QQ空间和传奇世界流连忘返；十年之前我们每月沐浴焚香把《读者》《意林》奉入神龛，Jay和Jolin在我们的复读机里复读不断；几十年前的小人书和连环画传看一时；百年之前梅兰芳、程砚秋就是娱乐圈的顶流。</p><p>高中语文读本上有挺多好看又让人难忘的文章，比如有一篇《唐诗过后是宋词》，作者是复旦教授葛兆光。听着《星星点灯》、《弯弯的月亮》，90年代时的他怀疑是不是“诗”的时代真的要让位给“歌”的时代。如今呢，这些流行也成了老歌，前面还被莫名冠以“经典”二字。似乎老去的东西总是会被自然而然地归类为经典，而流行于当下的必定是靡靡之音。谁能保证蔡徐坤的《Wait Wait Wait》百年之后不能被收录进《100首怀旧经典》呢。据说19年4月开始，微博上所有公开发布的博文都会被国家图书馆保存。也许短视频也能等到那一天。</p><p>四个字概括，毅种循环吧。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;最近一两年，因为工作、年长的压力、娃的磨人，空闲时间愈少，但是在手机上某个app的时间却格外多了起来。&lt;/p&gt;
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.kuang2.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="杂感" scheme="http://www.kuang2.cn/tags/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》的100条tips（下）</title>
    <link href="http://www.kuang2.cn/2021/02/27/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%9A%84100%E6%9D%A1tips%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://www.kuang2.cn/2021/02/27/《JavaScript高级程序设计》的100条tips（下）/</id>
    <published>2021-02-27T22:15:00.000Z</published>
    <updated>2022-04-11T02:53:32.348Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><h4 id="1-全局变量和window属性的区别"><a href="#1-全局变量和window属性的区别" class="headerlink" title="1.全局变量和window属性的区别"></a>1.全局变量和window属性的区别</h4><p>全局变量不能通过delete操作符删除，而window上定义的对象可以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.color;</span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">window</span>.age); <span class="comment">// 29 (全局变量没有被delete删除)</span></span><br><span class="line">alert(<span class="built_in">window</span>.color); <span class="comment">// undefined （window属性被delete删除）</span></span><br></pre></td></tr></table></figure><h4 id="2-setTimeout和setInterval"><a href="#2-setTimeout和setInterval" class="headerlink" title="2.setTimeout和setInterval"></a>2.setTimeout和setInterval</h4><p>第二个参数告诉JavaScript，再过多长时间把当前任务添加到列队中。如果列队是空的，那么添加的代码会立即执行；如果列队不为空，那么就要等前面的代码执行完后才能执行。</p><p>可以使用setTimeout代替setInterval，因为setInterval的某个func可能会在前一个func没结束就执行</p><h4 id="3-节点的读取和操作"><a href="#3-节点的读取和操作" class="headerlink" title="3.节点的读取和操作"></a>3.节点的读取和操作</h4><p>a.每个节点都有nodeType、nodeName、nodeValue属性</p><p>b.访问NodeList中的节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> count = someNode.childNodes.length</span><br></pre></td></tr></table></figure><p>c.操作节点</p><p>appendChild() 像childNodes列表的末尾插入一个节点，并返回插入的节点。（插入后各节点立刻得到更新）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode);<span class="comment">// 接收一个参数，即要插入的节点</span></span><br><span class="line">alert(returnedNode == newNode); <span class="comment">// true</span></span><br><span class="line">alert(someNode.lastChild == newNode); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 如果传入appendChild()的节点已存在，则移动该节点</span></span><br></pre></td></tr></table></figure><p>insertBefore() 把节点插入到特定位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只传一个参数，变成最后一个子节点</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, <span class="literal">null</span>); </span><br><span class="line">alert(returnedNode == someNode.lastChild); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传两个参数，变成第一个子节点</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, someNode.firstChild);</span><br><span class="line">alert(returnedNode == someNode.firstChild); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>replaceChild() 替换节点（传参：要替换的节点，被替换的节点）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnedNode = someNode.replaceChild(newNode, someNode.firstChild);</span><br></pre></td></tr></table></figure><p>removeChild() 移除节点</p><h4 id="4-H5与类相关的扩充"><a href="#4-H5与类相关的扩充" class="headerlink" title="4.H5与类相关的扩充"></a>4.H5与类相关的扩充</h4><p>a.获取节点：getElementsByCalssName()</p><p>b.操作类名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.classList.remove(<span class="string">"user"</span>); <span class="comment">//移除类名</span></span><br><span class="line">div.classList.add(<span class="string">"current"</span>); <span class="comment">//添加类名</span></span><br><span class="line">div.classList.toggle(<span class="string">"current"</span>); <span class="comment">//切换类名（如果有就删除，没有就添加）</span></span><br><span class="line">div.classList.contains(); <span class="comment">//是否包含</span></span><br></pre></td></tr></table></figure><h4 id="5-焦点管理"><a href="#5-焦点管理" class="headerlink" title="5.焦点管理"></a>5.焦点管理</h4><p>document.activeElement: 引用当前获得了焦点的元素</p><p>document.hasFocus() 判断文档是否获得了焦点</p><h4 id="6-自定义数据属性"><a href="#6-自定义数据属性" class="headerlink" title="6.自定义数据属性"></a>6.自定义数据属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">data-appId</span>=<span class="string">"12345"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用元素的dataset属性获取自定义属性的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> appId = div.dataset.appId; <span class="comment">// "12345"</span></span><br></pre></td></tr></table></figure><h4 id="7-专有扩展"><a href="#7-专有扩展" class="headerlink" title="7.专有扩展"></a>7.专有扩展</h4><p>特指部分浏览器先实现，后来被纳入标准的属性或方法</p><p>a.children属性(与childNodes的区别：children是非标准属性，只返回HTML子节点)</p><p>b.contains()方法：判断被检测的节点是否为后代节点。类似还有comoareDocumentPosition()方法，判断两个节点的关系（前、后、包含和被包含等）</p><p>c.innerText和outerText：非标准属性</p><p>d.滚动：（部分浏览器实现）</p><blockquote><p>scrollIntoViewIfNeeded(alignCenter)：当前元素不可见时滚动至可见</p><p>scrollByLines(lineCount)：滚动指定的行高</p><p>scrollByPages(pageCount)：滚动指定的页面高度</p></blockquote><h4 id="8-样式"><a href="#8-样式" class="headerlink" title="8.样式"></a>8.样式</h4><blockquote><p>cssText 访问或设置style特性的css代码</p><p>getPropertyValue(propertyName)：返回给定属性的字符串值</p><p>removeProperty(propertyName)：从样式中删除给定属性</p><p>setProperty(propertyName, value, priority)：将给定属性设置为相应值，并加上优先权标志</p><p>getComputedStyle() 返回计算的样式（返回一个对象，从对象中取值）</p><p>样式表操作：addRule()，removeRule()等</p></blockquote><h4 id="9-元素大小"><a href="#9-元素大小" class="headerlink" title="9.元素大小"></a>9.元素大小</h4><p>a.偏移量</p><p>元素可见大小由其高度、宽度决定，包括内边距、滚动条和边框大小。不包括外边距。</p><blockquote><p>offsetHeight: 元素在垂直方向上占用的空间大小。包括高度、可见水平滚动条高度、上边框高度和下边框高度</p><p>offsetWidth: 元素在水平方向占用的空间大小</p><p>offsetLeft: 元素的左外边框至包含元素的左内边框之间的像素距离</p><p>offsetTop: 元素的上外边框至包含元素的上内边框之间的像素距离</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-7f77ebdd1040d03cb069700d3084d79e_720w.jpg" alt="img"></p><p>b.客户区大小</p><p>元素内容及其内边距所占据的空间大小（不包括边框、滚动条）</p><blockquote><p>clientWidth: 元素内容区宽度加上左右内边距宽度</p><p>clientHeight: 元素内容区高度加上上下内边距高度</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190830174821356.PNG" alt="clientWidth和clientheight 主要表示"></p><p>c.滚动大小</p><p>包含滚动内容的元素的大小</p><blockquote><p>scrollHeight: 没有滚动条的情况下，元素内容的总高度</p><p>scrollWidth: 没有滚动条的情况下，元素内容的总宽度</p><p>scrollLeft: 被隐藏在内容区域左侧的像素数。设置此属性可以改变元素的滚动位置</p><p>scrollTop: 被隐藏在内容区域上方的像素数。设置此属性可以改变元素的滚动位置</p></blockquote><p><img src="http://git-hexo-blog.oss-cn-beijing.aliyuncs.com/scroll-dimension.png" alt="scroll-dimension"></p><h4 id="10-遍历（都是深度优先）"><a href="#10-遍历（都是深度优先）" class="headerlink" title="10.遍历（都是深度优先）"></a>10.遍历（都是深度优先）</h4><p>NodeIterator接收四个参数：</p><blockquote><p>root: 想要作为搜索起点的树中的节点</p><p>whatToShow: 表示要访问哪些节点的数字代码</p><p>filter: NodeFilter对象，或者应该接收还是拒绝某些特定节点的函数</p><p>entityReferenceExpansion: 布尔值，表示是否要扩展实体引用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span><br><span class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, NULL, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> node = iterator.nextNode();</span><br><span class="line"><span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">    alert(node.tagName); <span class="comment">//输出标签名</span></span><br><span class="line">    node = iterator.nextNode(); <span class="comment">//另外还有previousNode()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeWalker：用法类似</p><h4 id="11-DOM的范围"><a href="#11-DOM的范围" class="headerlink" title="11.DOM的范围"></a>11.DOM的范围</h4><p>使用document.createRange()来创建DOM范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange(),</span><br><span class="line">    range2 = <span class="built_in">document</span>.createRange(),</span><br><span class="line">    p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</span><br><span class="line">range1.selectNode(p1);</span><br><span class="line">range2.selectNodeContent(p1);</span><br></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/943101/201701/943101-20170105195620159-1016665497.png" alt="img"></p><h4 id="12-事件流和事件处理"><a href="#12-事件流和事件处理" class="headerlink" title="12.事件流和事件处理"></a>12.事件流和事件处理</h4><p>“DOM2级事件”规定事件流包括三个阶段：事件捕获、处于目标和事件冒泡</p><p>DOM0 级事件处理程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myLink = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</span><br><span class="line">myLink.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event.preventDefault(); <span class="comment">// 阻止默认事件, 只有cancelable为true的事件才能使用</span></span><br><span class="line">&#125; <span class="comment">//onclick 也是btn标签的属性之一</span></span><br></pre></td></tr></table></figure><p>DOM2 级事件处理程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;  <span class="comment">//IE 中是 attachEvent()</span></span><br><span class="line">    alert(event.currentTarget == <span class="keyword">this</span>); <span class="comment">// true 在btn上绑定的事件 ，这三个值相同</span></span><br><span class="line">    alert(event.target == <span class="keyword">this</span>); <span class="comment">// true</span></span><br><span class="line">    event.stopPropagation();<span class="comment">// 停止冒泡</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="13-鼠标事件相关"><a href="#13-鼠标事件相关" class="headerlink" title="13.鼠标事件相关"></a>13.鼠标事件相关</h4><blockquote><p>只有在一个元素上相继触发mousedown和mouseup事件，才会触发click事件。触发顺序：mousedown/mouseup/click</p></blockquote><p>鼠标事件的位置</p><blockquote><p>a.客户区位置：clientX和clientY</p><p>b.页面坐标位置：pageX和pageY(页面没有滚动时，与clientX和clientY相等，有滚动则一般pageX和pageY更大)</p><p>b.屏幕坐标位置：screenX和screenY</p></blockquote><p>修改键</p><blockquote><p>shiftKey / ctrlKey / altKey / metaKey 均为布尔值，属于event的属性，用来判断是否同时按下了键</p></blockquote><p>相关元素</p><blockquote><p>mouseover和mouseout事件独有的relatedTarget属性，提供了鼠标移入移出的相关元素信息</p></blockquote><p>鼠标按钮</p><blockquote><p>mousedown和mouseup事件独有button属性，用来判断是鼠标的哪个按钮被按下（0左、1中、2右）</p></blockquote><p>mousewheel鼠标滚轮事件</p><h4 id="14-键盘事件相关"><a href="#14-键盘事件相关" class="headerlink" title="14.键盘事件相关"></a>14.键盘事件相关</h4><p>三个键盘事件：keydown、keypress、keyup（按执行顺序）。以及一个文本事件：textInput（DOM3）</p><p>event.keyCode // 键码</p><p>event.key // 键文本 (DOM3)</p><p>event.getModifierState() // 检测修改键是否被按下，传入修改键的字符串（如Shift、Control等）</p><p>textInput: 在可编辑区域触发，并且只会在按下输入实际字符的键才会触发。其event.data属性等于输入键的字符串。另外还有inputMethod属性（仅IE支持），表示输入的方式，比如1键盘输入，2粘贴输入，3拖放输入等</p><h4 id="15-DOM变动事件"><a href="#15-DOM变动事件" class="headerlink" title="15.DOM变动事件"></a>15.DOM变动事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMSubtreeModified"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"dom发生变动"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMNodeInserted"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"有元素被加入"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMNodeRemoved"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"有元素被移除"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMCharacterDataModified"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"有dom文本发生变化"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">".textmodified"</span>).addEventListener(<span class="string">"DOMCharacterDataModified"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"设置在即将改变的div上的监听事件有dom文本发生变化"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="16-HTML5事件"><a href="#16-HTML5事件" class="headerlink" title="16.HTML5事件"></a>16.HTML5事件</h4><p>a.contextmenu事件</p><p>b.beforeunload事件</p><p>c.DOMContentLoaded事件 和 readystatechange事件</p><p>d.hashchange事件</p><p>e.触摸设备事件：横竖屏、设备方向改变、设备移动等</p><p>f.触摸事件</p><blockquote><p>touchstart / touchmove / touchend / touchcancel</p><p>手势事件、、</p></blockquote><h4 id="17-模拟事件"><a href="#17-模拟事件" class="headerlink" title="17.模拟事件"></a>17.模拟事件</h4><p>模拟鼠标事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="comment">// 创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"MouseEvents"</span>);</span><br><span class="line"><span class="comment">//初始化事件对象</span></span><br><span class="line">event.initMouseEvent(<span class="string">"click"</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">btn.dispatchEvent(event);</span><br></pre></td></tr></table></figure><h4 id="18-取得选择的文本"><a href="#18-取得选择的文本" class="headerlink" title="18.取得选择的文本"></a>18.取得选择的文本</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="string">"textbox1"</span>];</span><br><span class="line">textbox.selectionStart; <span class="comment">//文本开始</span></span><br><span class="line">textbox.selectionEnd; <span class="comment">//文本结束</span></span><br><span class="line">textbox.value = <span class="string">"Hello world!"</span>;</span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">//"Hel"</span></span><br><span class="line"><span class="comment">//要看到选择效果，需要调用select() 使文本框获得焦点</span></span><br></pre></td></tr></table></figure><h4 id="19-富文本相关"><a href="#19-富文本相关" class="headerlink" title="19.富文本相关"></a>19.富文本相关</h4><p>可以使用document.execCommand()对文档执行预定义的命令，包括设置背景色、改变字体、插入元素、操作剪贴板等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对iframe富文本</span></span><br><span class="line">frames[<span class="string">"richedit"</span>].document.execCommand(<span class="string">"bold"</span>, <span class="literal">false</span>, <span class="literal">null</span>); <span class="comment">//转换粗体</span></span><br><span class="line"><span class="comment">// 针对contenteditable属性为true的区块</span></span><br><span class="line"><span class="built_in">document</span>.execCommand(<span class="string">"createlink"</span>, <span class="literal">false</span>, <span class="string">"http://www/wrox.com"</span>); <span class="comment">// 创建链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 富文本选区</span></span><br><span class="line"><span class="keyword">var</span> selection = frames[<span class="string">"richedit"</span>].getSelection(); </span><br><span class="line"><span class="keyword">var</span> selectedText = selection.toString(); <span class="comment">//取得选择的文本</span></span><br></pre></td></tr></table></figure><h4 id="20-跨文档消息传递"><a href="#20-跨文档消息传递" class="headerlink" title="20.跨文档消息传递"></a>20.跨文档消息传递</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeWindow = <span class="built_in">document</span>.getElementById(<span class="string">"myIframe"</span>).contentWindow;</span><br><span class="line"><span class="comment">// 两个参数：一个字符串数据，和一个消息接收方来自哪个域的字符串</span></span><br><span class="line">iframeWindow.postMessage(<span class="string">"A secret"</span>, <span class="string">"http://www.wrox.com"</span>);</span><br><span class="line"><span class="comment">//onmessage三个参数：data传入的字符串，origin发送方所在的域，source发送方的windows对象的代理(不是实际的window对象)</span></span><br></pre></td></tr></table></figure><h4 id="21-原生拖放"><a href="#21-原生拖放" class="headerlink" title="21.原生拖放"></a>21.原生拖放</h4><p>拖动某元素时，依次触发下列事件</p><blockquote><p>dragstart，drag，dragend</p></blockquote><p>当元素被拖放到一个有效的放置目标时，下列事件依次发生：</p><blockquote><p>dragenter，dragover，dragleave或drop</p></blockquote><p>拖放的数据传递</p><blockquote><p>使用dataTransfer对象的两个方法：getData() 和setData()</p><p>以及确定被拖动元素和目标元素能接收什么操作：dropEffect属性和effectAllowed属性</p></blockquote><p>可拖动</p><blockquote><p>默认情况下，图像、链接和文本可以拖动，另外还有H5属性draggable</p></blockquote><h4 id="22-常见错误类型"><a href="#22-常见错误类型" class="headerlink" title="22.常见错误类型"></a>22.常见错误类型</h4><blockquote><p>RangeError 数字超出允许的值范围时</p><p>ReferenceError 当对变量/项的引用被破坏或不存在时，或者变量/项不存在。</p><p>SyntaxError 语法错误 js无法理解时</p><p>TypeError 类型错误 比如调用了数值类型不存在的字符串方法时</p><p>URIError URI 传参错误</p><p>EvalError 非法调用eval()</p><p>InternalError 栈溢出，或者是无限递归</p></blockquote><h4 id="23-JSON"><a href="#23-JSON" class="headerlink" title="23.JSON"></a>23.JSON</h4><p>JSON包含三种类型：简单值、对象和数组</p><p>其对象与JavaScript的对象字面量的区别：</p><blockquote><p>1.JSON必须给属性加双引号（值不用加引号）</p><p>2.没有声明变量（没有变量 的概念），没有末尾的分号</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;Nicholas&quot;,</span><br><span class="line">&quot;age&quot;: 29 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以是数组</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">25</span>, <span class="string">"hi"</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p>JSON对象的两个方法：</p><blockquote><p>stringify() 把JavaScript对象序列化为JSON字符串</p><pre><code>a.使用stringify()序列化时，函数、原型和值为undefined的属性会被跳过</code></pre><p>​ b.另外还接收两个参数，第一个参数用于过滤（数组或函数），第二个参数用于控制缩进</p><p>parse() 把JSON字符串解析为原生JavaScript值</p><p>parse()也可以接收另一个函数参数，功能与stringify()的类似</p></blockquote><p>给对象定义toJSON()方法，则stringify()序列化时直接执行此方法</p><h4 id="24-跨域技术"><a href="#24-跨域技术" class="headerlink" title="24.跨域技术"></a>24.跨域技术</h4><p>a.图像Ping：简单、单向的跨域通信</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Done!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">"http://www.example.com/test?name=Nicholas"</span>;</span><br><span class="line"><span class="comment">// 缺点：只能发送GET请求，无法访问服务器的响应文本</span></span><br></pre></td></tr></table></figure><p>b.JSONP</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">///接收服务器返回的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.src = <span class="string">"http://freegeoip.net/json/?callback=handleResponse"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</span><br><span class="line"><span class="comment">// 缺点：可能夹带恶意代码，无法确定是否失败</span></span><br></pre></td></tr></table></figure><p>c.Comet</p><p>长轮询（服务器接收请求后一直保持连接直到发送数据）和流（只有一个HTTP连接，保持打开，间歇发送数据但不关闭）</p><p>d.SSE</p><h4 id="25-Web-Sockets"><a href="#25-Web-Sockets" class="headerlink" title="25.Web Sockets"></a>25.Web Sockets</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    text: <span class="string">"Hello world!"</span>,</span><br><span class="line">    clientId: <span class="string">"asdfp8734rew"</span></span><br><span class="line">&#125;</span><br><span class="line">socket.send(<span class="built_in">JSON</span>.stringify(message));</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data;</span><br><span class="line">&#125; <span class="comment">// 或者使用onopen, onerror, onclose</span></span><br></pre></td></tr></table></figure><h4 id="26-安全的类型检测"><a href="#26-安全的类型检测" class="headerlink" title="26.安全的类型检测"></a>26.安全的类型检测</h4><p>typeof的判断并不可靠，比如某些浏览器下typeof 正则返回“function”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> /[a-z]/g <span class="comment">// chrome下返回object</span></span><br></pre></td></tr></table></figure><p>instanceof在多个全局作用域下不能准确判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// 如果value是在另一个frame下定义的，则返回false</span></span><br></pre></td></tr></table></figure><h4 id="27-作用域安全"><a href="#27-作用域安全" class="headerlink" title="27.作用域安全"></a>27.作用域安全</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.job = job;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age, job)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="28-惰性载入函数"><a href="#28-惰性载入函数" class="headerlink" title="28.惰性载入函数"></a>28.惰性载入函数</h4><p>在某些不同浏览器使用不同函数的情形中，可以使用惰性载入的方式，减少每次调用函数的判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始函数，针对不同浏览器环境有很多判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xx)&#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式一 在判断中覆盖原函数，即判断的代码只在第一次执行时执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">        createXHR = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;xxx&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二 在声明时直接返回正确的函数，并立即自执行此函数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;xxx&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h4 id="29-防篡改对象"><a href="#29-防篡改对象" class="headerlink" title="29.防篡改对象"></a>29.防篡改对象</h4><p>a.不可扩展的对象：不能新增属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span>&#125;;</span><br><span class="line">alert(<span class="built_in">Object</span>.isExtensible(person)); <span class="comment">// true(判断是否可扩展)</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(person);</span><br><span class="line">person.age = <span class="number">29</span>;</span><br><span class="line">alert(person.age); <span class="comment">// undefined</span></span><br><span class="line">alert(<span class="built_in">Object</span>.isExtensible(person)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>b.密封对象：不能新增、删除属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.seal(person);</span><br><span class="line">person.age = <span class="number">29</span>; <span class="comment">// 操作在严格模式下报错</span></span><br><span class="line">alert(person.age); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line">alert(person.name); <span class="comment">// "Nicholas"</span></span><br><span class="line">alert(<span class="built_in">Object</span>.isSealed(person)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>c.冻结对象：不能新增、删除和修改属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.freeze(person);</span><br><span class="line"><span class="built_in">Object</span>.isFrozen(person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="30-节流和防抖"><a href="#30-节流和防抖" class="headerlink" title="30.节流和防抖"></a>30.节流和防抖</h4><h4 id="31-cookie：document-cookie-“name-123”-相当于在cookie列表中增加一条name-123的信息，而非重写整个cookie列表"><a href="#31-cookie：document-cookie-“name-123”-相当于在cookie列表中增加一条name-123的信息，而非重写整个cookie列表" class="headerlink" title="31.cookie：document.cookie = “name=123” 相当于在cookie列表中增加一条name=123的信息，而非重写整个cookie列表"></a>31.cookie：document.cookie = “name=123” 相当于在cookie列表中增加一条name=123的信息，而非重写整个cookie列表</h4><h4 id="32-性能优化"><a href="#32-性能优化" class="headerlink" title="32.性能优化"></a>32.性能优化</h4><p>a.避免对象上的属性查找：因为对象的属性查找会查找原型链</p><blockquote><p>可以使用数组代替对象的属性查找</p><p>级数过多的属性使用变量缓存</p></blockquote><p>b.优化循环</p><blockquote><p>推荐减值迭代</p><p>使用后测试循环：即do-while循环，避免终止条件的计算</p><p>展开循环：减少了条件判断</p></blockquote><p>c.最小化语句数</p><blockquote><p>例如声明：var count =5,color=”blue”,values=[1,2];</p><p>使用数组和对象字面量：var obj = {name:1,age:2}</p></blockquote><p>d.优化DOM操作</p><blockquote><p>最小化（减少）现场更新：比如使用fragment的dom片段整个插入代替批量的dom插入</p><p>使用innerHTML</p><p>缓存dom对变量</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h4 id=&quot;1-全局变量和window属性的区别&quot;&gt;&lt;a href=&quot;#1-全局变量和window属性的区别&quot; 
      
    
    </summary>
    
      <category term="技术" scheme="http://www.kuang2.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS JS基础" scheme="http://www.kuang2.cn/tags/JS-JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》的100条tips（上）</title>
    <link href="http://www.kuang2.cn/2021/02/26/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%9A%84100%E6%9D%A1tips%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://www.kuang2.cn/2021/02/26/《JavaScript高级程序设计》的100条tips（上）/</id>
    <published>2021-02-26T22:10:00.000Z</published>
    <updated>2022-04-11T02:53:32.348Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><h4 id="1-后置递增、递减-与-前置递增、递减的最大区别，是递增和递减操作是在包含他们的语句被求值之后才执行："><a href="#1-后置递增、递减-与-前置递增、递减的最大区别，是递增和递减操作是在包含他们的语句被求值之后才执行：" class="headerlink" title="1.后置递增、递减 与 前置递增、递减的最大区别，是递增和递减操作是在包含他们的语句被求值之后才执行："></a>1.后置递增、递减 与 前置递增、递减的最大区别，是递增和递减操作是在包含他们的语句被求值之后才执行：</h4><p>前置递减：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> num3 = --num1 + num2; <span class="comment">//等于21，（先对num1进行递减后求值）</span></span><br><span class="line"><span class="keyword">var</span> num4 = num1 + num2; <span class="comment">//等于21</span></span><br></pre></td></tr></table></figure><p>后置递减：（后置操作延迟了对值的递增或递减操作）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> num3 = num1-- + num2; <span class="comment">//等于22  （先对num1求值，执行加法，再对num1递减）</span></span><br><span class="line"><span class="keyword">var</span> num4 = num1 + num2; <span class="comment">//等于21</span></span><br></pre></td></tr></table></figure><h4 id="2-所有函数的参数都是按值传递的："><a href="#2-所有函数的参数都是按值传递的：" class="headerlink" title="2.所有函数的参数都是按值传递的："></a>2.所有函数的参数都是按值传递的：</h4><p>把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = addTen(count);</span><br><span class="line">alert(count); <span class="comment">//20，没有变化</span></span><br><span class="line">alert(result); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">// 'Nicholas'</span></span><br></pre></td></tr></table></figure><p>引用类型的参数看上去是按引用传递的，但实际上确实是按值传递的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">'Greg'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">// 'Nicholas'  person这个变量没有因为重新赋值而改变，说明传递参数传递的是person纸箱的object地址（值）</span></span><br></pre></td></tr></table></figure><h4 id="3-JavaScript没有块级作用域"><a href="#3-JavaScript没有块级作用域" class="headerlink" title="3.JavaScript没有块级作用域"></a>3.JavaScript没有块级作用域</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(color); <span class="comment">// "blue";</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h4 id="4-JavaScript的垃圾收集："><a href="#4-JavaScript的垃圾收集：" class="headerlink" title="4.JavaScript的垃圾收集："></a>4.JavaScript的垃圾收集：</h4><blockquote><p>1.标记清除</p><p>2.引用计数</p></blockquote><h4 id="5-数组模拟栈结构和列队结构："><a href="#5-数组模拟栈结构和列队结构：" class="headerlink" title="5.数组模拟栈结构和列队结构："></a>5.数组模拟栈结构和列队结构：</h4><p>栈结构（后进先出）</p><blockquote><p>push方法接收任意数量个参数，把他们逐个添加到数组末尾，并返回修改后数组的长度</p><p>pop方法则从数组末尾移除最后一项，返回移除的项</p></blockquote><p>列队结构（先进先出）</p><blockquote><p>push方法在数组末尾插入新值</p><p>shift()移除数组的第一个项并返回该项</p></blockquote><p>或者从相反方向模拟列队：</p><blockquote><p>unshift方法在数组前端添加任意个项并返回新数组的长度</p><p>pop方法则从数组末尾移除最后一项，返回移除的项</p></blockquote><h4 id="6-数组排序"><a href="#6-数组排序" class="headerlink" title="6.数组排序"></a>6.数组排序</h4><p>默认情况下，sort()方法按升序排列（小值在前，大值在后），原理是调用每个数组 项的toString()方法，然后比较字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values); <span class="comment">// 0, 1, 10, 15, 5 (字符串10在5之前)</span></span><br></pre></td></tr></table></figure><p>sort()也可以接收一个比较函数，比较函数接收两个参数，如果想让第一个参数在第二个之前，则返回负数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, vlaue2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value1 &lt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者简单相减，用于数值类型 或者valueOf能返回数组类型的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, vlaue2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value1 - value2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">// 0, 1, 5, 10, 15</span></span><br></pre></td></tr></table></figure><h4 id="7-正则表达式"><a href="#7-正则表达式" class="headerlink" title="7.正则表达式"></a>7.正则表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="literal">null</span>, i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    re = <span class="regexp">/cat/g</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(re.test(<span class="string">"catastrophe"</span>)); <span class="comment">// 每次返回true （在新的浏览器版本中）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"---"</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"cat"</span>, <span class="string">"g"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(re.test(<span class="string">"catastrophe"</span>)); <span class="comment">// 每次返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上案例说明正则表达式字面量就等同于直接调用RegExp构造函数，每次创建新的实例</p><p>关于exec和match的区别，见文章：<a href="https://www.cnblogs.com/sunxiaorui/p/4396089.html" target="_blank" rel="noopener">javascript正则表达式exec()与match()的区别说明</a> 最大区别是：exec是正则表达式的方法（参数是字符串），match是字符串的方法（参数是正则表达式）</p><h4 id="8-Function类型"><a href="#8-Function类型" class="headerlink" title="8.Function类型"></a>8.Function类型</h4><p>函数名只是指向函数的指针：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherSum = sum;</span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure><p>函数内部属性</p><blockquote><p>arguments: 类数组对象，包含传入函数的所有参数</p><p>arguments.callee: 指向当前函数（严格模式无效）</p><p>arguments.callee.caller: 调用当前函数的函数或环境（调用栈？）（严格模式无效）</p><p>length: 函数希望接收的命名参数的个数</p><p>prototype: 实例方法的真正所在</p></blockquote><p>每个函数都包含两个非继承而来的方法：apply()和call()</p><blockquote><p>apply() 接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组</p><p>call() 接收多个参数，第一个参数是作用域，其余的就是其他参数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, ...arguments); <span class="comment">// ...arguments 扩展运算符 表示分别传入（逐一传入，而非一次传入整个数组）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"结果："</span>, callSum2(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h4 id="9-基本包装类型"><a href="#9-基本包装类型" class="headerlink" title="9.基本包装类型"></a>9.基本包装类型</h4><p>Object构造函数会像工厂方法一样，根据传入值的类型返回响应基本包装类型的实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);</span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>传入字符就会创建String的实例，传入数值就会得到Number的实例，传入布尔值就会得到Boolean的实例</p><p>注意，使用new 调用基本包装类型的构造函数，域直接调用同名的转型函数不一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">//转型函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> number); <span class="comment">// "number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> obj); <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><p>类似Boolean类型问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> falseObject = <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">// false;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> falseObject = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure><h4 id="10-字符串方法"><a href="#10-字符串方法" class="headerlink" title="10.字符串方法"></a>10.字符串方法</h4><p>split()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>;</span><br><span class="line"><span class="keyword">var</span> color1 = colorText.split(<span class="string">","</span>); <span class="comment">// ["red", "blue", "green", "yellow"]</span></span><br><span class="line"><span class="keyword">var</span> color2 = colorText.split(<span class="string">","</span>, <span class="number">2</span>); <span class="comment">// ["red", "blue"]</span></span><br><span class="line"><span class="keyword">var</span> color3 = colorText.split(<span class="regexp">/[^\,]+/</span>); <span class="comment">//匹配任意非逗号的字符 ["", ",", ",", ",", ""]</span></span><br></pre></td></tr></table></figure><h4 id="11-内置对象之Global对象（浏览器环境中就是window）"><a href="#11-内置对象之Global对象（浏览器环境中就是window）" class="headerlink" title="11.内置对象之Global对象（浏览器环境中就是window）"></a>11.内置对象之Global对象（浏览器环境中就是window）</h4><blockquote><p>isNaN()，isFinite()，parseInt()，parseFloat()都是Global的方法</p></blockquote><p>URI编码方法：（有效的URI不能包含某些字符，例如空格，因此需要此方法编码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">"http://www.wrox.com/illegal value.htm#start"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//"http://www.wrox.com/illegal%20value.htm#start"</span></span><br><span class="line">alert(<span class="built_in">encodeURI</span>(uri));<span class="comment">//一般用于整个URI，不会对本身属于URI的特殊字符编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span></span><br><span class="line">alert(<span class="built_in">encodeURIComponent</span>(uri));<span class="comment">//一般用于URI的某一段，会对所有非标准字符编码（此处不应该使用此方法）</span></span><br></pre></td></tr></table></figure><p>对应解码：decodeURI() 和 decodeURIComponent()</p><h4 id="12-Math对象的方法"><a href="#12-Math对象的方法" class="headerlink" title="12.Math对象的方法"></a>12.Math对象的方法</h4><p>random方法套用公式：</p><blockquote><p>值 = Math.floor( Math.random() * 可能值的总数 + 第一个可能的值)</p></blockquote><p>四舍五入方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Math.ceil向上舍入</span></span><br><span class="line">alert(<span class="built_in">Math</span>.ceil(<span class="number">25.9</span>)); <span class="comment">//26</span></span><br><span class="line">alert(<span class="built_in">Math</span>.ceil(<span class="number">25.5</span>)); <span class="comment">//26</span></span><br><span class="line">alert(<span class="built_in">Math</span>.ceil(<span class="number">25.1</span>)); <span class="comment">//26</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.round标准舍入(即四舍五入)</span></span><br><span class="line">alert(<span class="built_in">Math</span>.round(<span class="number">25.9</span>)); <span class="comment">//26</span></span><br><span class="line">alert(<span class="built_in">Math</span>.round(<span class="number">25.5</span>)); <span class="comment">//26</span></span><br><span class="line">alert(<span class="built_in">Math</span>.round(<span class="number">25.1</span>)); <span class="comment">//25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.floor向下舍入</span></span><br><span class="line">alert(<span class="built_in">Math</span>.floor(<span class="number">25.9</span>)); <span class="comment">//25</span></span><br><span class="line">alert(<span class="built_in">Math</span>.floor(<span class="number">25.5</span>)); <span class="comment">//25</span></span><br><span class="line">alert(<span class="built_in">Math</span>.floor(<span class="number">25.1</span>)); <span class="comment">//25</span></span><br></pre></td></tr></table></figure><h4 id="13-对象的两种属性：数据属性和访问器属性"><a href="#13-对象的两种属性：数据属性和访问器属性" class="headerlink" title="13.对象的两种属性：数据属性和访问器属性"></a>13.对象的两种属性：数据属性和访问器属性</h4><p>a.数据属性</p><blockquote><p>[[Configurable]] 能否通过delete删除属性而重新定义属性，能否修改属性的特性（默认值true）</p><p>[[Enumerable]] 能否通过for-in 循环返回属性（默认值true）</p><p>[[Writable]] 能否修改属性的值（默认值true）</p><p>[[Value]] 属性的数据值（默认值undefined）</p></blockquote><p>要修改属性的默认特性，必须使用Object.defineProperty()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(person.name); <span class="comment">// "Nicholas"</span></span><br><span class="line">person.name = <span class="string">"Greg"</span>; <span class="comment">//无效，严格模式报错</span></span><br><span class="line">alert(person.name); <span class="comment">// Nicholas</span></span><br></pre></td></tr></table></figure><p>注意，将Configurable设置为false之后，将无法再使用Object.defineProperty()配置其属性</p><p>b.访问器属性</p><blockquote><p>[[Configurable]] 能否通过delete删除属性而重新定义属性，能否修改属性的特性（默认值true）</p><p>[[Enumerable]] 能否通过for-in 循环返回属性（默认值true）</p><p>[[Get]] 在读取属性时调用的函数（默认值undefined）</p><p>[[Set]] 在设置属性时调用的函数（默认值undefined）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    _year: <span class="number">2014</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>c.定义多个属性：Object.defineProperties()</p><p>d.读取属性的特性：Object.getOwnPropertyDescriptor()</p><h4 id="14-原型式继承的Object函数"><a href="#14-原型式继承的Object函数" class="headerlink" title="14.原型式继承的Object函数"></a>14.原型式继承的Object函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ECMAScript 5 通过新增Object.create()方法规范了原型式继承。接收两个参数：一个用作新对象原型的对象，和（可选的）一个为新对象定义额外属性的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Count"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> antherPerson = <span class="built_in">Object</span>.create(person); <span class="comment">// 或者使用前文的object函数</span></span><br><span class="line">antherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">antherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAntherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAntherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAntherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.name); <span class="comment">// "Nicholas"</span></span><br><span class="line">alert(person.friends);  <span class="comment">// "Shelby,Count,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> antherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">"Greg"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(antherPerson.name); <span class="comment">// "Greg"</span></span><br></pre></td></tr></table></figure><h4 id="15-作用域链的副作用"><a href="#15-作用域链的副作用" class="headerlink" title="15.作用域链的副作用"></a>15.作用域链的副作用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createFunctions()); <span class="comment">// 每个函数都返回10</span></span><br></pre></td></tr></table></figure><p>在定义result函数数组时，i看上去是正确的。但当它们要执行时，createFunctions早就执行结束了，此时查找到i=10，因此result函数数组里的函数都返回10。也就是说，result数组函数里的i，是在执行时才去找的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createFunctions()); <span class="comment">// 每个函数都返回10</span></span><br></pre></td></tr></table></figure><h4 id="16-闭包的this"><a href="#16-闭包的this" class="headerlink" title="16.闭包的this"></a>16.闭包的this</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object =&#123;</span><br><span class="line">    name: <span class="string">" My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">// The Window</span></span><br></pre></td></tr></table></figure><p>该例子中的匿名函数，没有取到其外部作用域对象object的name。</p><p>原因是object.getNameFunc()执行后，匿名函数暴露在全局作用域下，此时在执行此匿名函数，this就指向全局对象window了。</p><blockquote><p>匿名函数的this通常指向全局window</p></blockquote><p>可以这样修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object =&#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">// My Object特殊</span></span><br></pre></td></tr></table></figure><p>特殊情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object =&#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object.getName(); <span class="comment">// "My Object"</span></span><br><span class="line">(object.getName)(); <span class="comment">// "My Object"</span></span><br><span class="line">(object.getName = object.getName)(); <span class="comment">// "The Window"</span></span><br></pre></td></tr></table></figure><p>以上示例的关键在于， 赋值语句是有返回值的，返回值就是<strong>所赋的值</strong> 。因此(object.getName = object.getName)的结果就是原函数getName。然后在当前全局环境执行getName，即得到“The Window”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b = (a = <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="17-函数声明和函数表达式"><a href="#17-函数声明和函数表达式" class="headerlink" title="17.函数声明和函数表达式"></a>17.函数声明和函数表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//do something </span></span><br><span class="line">&#125;(); <span class="comment">//出错 函数声明后面不能直接跟括号</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125;)(); <span class="comment">// 加上小括号之后，函数声明变成了函数表达式，函数表达式后面可以跟括号</span></span><br></pre></td></tr></table></figure><p>类似如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'test'</span>)&#125;)(); <span class="comment">// 正常执行function，弹出“test”</span></span><br></pre></td></tr></table></figure><p>（截止《JavaScript高级程序设计》第192页）</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h4 id=&quot;1-后置递增、递减-与-前置递增、递减的最大区别，是递增和递减操作是在包含他们的语句被求值之后才执行
      
    
    </summary>
    
      <category term="技术" scheme="http://www.kuang2.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS JS基础" scheme="http://www.kuang2.cn/tags/JS-JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>《CSS世界》的100条tips</title>
    <link href="http://www.kuang2.cn/2021/02/21/%E3%80%8ACSS%E4%B8%96%E7%95%8C%E3%80%8B%E7%9A%84100%E6%9D%A1tips/"/>
    <id>http://www.kuang2.cn/2021/02/21/《CSS世界》的100条tips/</id>
    <published>2021-02-21T21:10:00.000Z</published>
    <updated>2022-04-11T02:53:32.348Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --><p>标题是唬人的，实际只记录了39条。如下(使用了html效果的，请直接右键查看html源码)：</p><p>1.display为block的元素不必设置width，否则丢失流动性（流动性即可以水平占满空间）</p><div style="border:1px solid grey;margin-bottom:10px"><div style="background-color:red;width:50px;height:50px"></div></div><p>2.格式化宽度：绝对定位元素宽度由外部元素决定（通常情况由内部元素决定，即包裹性）</p><div style="border:1px solid grey;margin-bottom:10px;width:200px;height:100px;position:relative"><div style="background-color:red;height:50px;position:absolute;left:20px;right:20px"></div></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.包裹性：按钮文字越多宽度越宽，但是会在容器宽度处换行</p><div style="border:1px solid grey;margin-bottom:10px;width:50px;height:100px"><button>我是按钮2221</button></div><p>参考：<a href="https://demo.cssworld.cn/3/2-4.php" target="_blank" rel="noopener">https://demo.cssworld.cn/3/2-4.php</a></p><p>借此特性实现：文字少时居中，文字多时靠左显示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">text-align</span>:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="border:1px solid grey;margin-bottom:10px;width:200px;height:100px;text-align:center"><div style="display:inline-block;background-color:red;width:50px;text-align:left">我是居中的div</div></div><p>4.height:100% 无效。规范说明：如果包含块的高度没有显式指定，并且该元素不是绝对定位，则计算值是auto</p><p>5.max-width会覆盖width!important，min-width会覆盖max-width</p><p><a href="https://demo.cssworld.cn/3/3-1.php" target="_blank" rel="noopener">https://demo.cssworld.cn/3/3-1.php</a></p><p>6.可以使用max-height：一个足够大的值，来实现展开收起动画的内容的动态高度</p><p>7.幽灵空白节点（font-size:0则高度为0）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#98b1d4</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; // 此时会有18px的高度，即空白节点的高度</span><br></pre></td></tr></table></figure><div style="background-color:#98b1d4;margin-bottom:10px;line-height:18px"><span style="display:inline-block"></span></div><p>8.替换元素特性：</p><blockquote><p>1.内容外观不受页面css的影响</p><p>2.有自己的尺寸（比如video、iframe、canvas，默认尺寸300*150，或者img为0，表单元素与浏览器有关）</p><p>3.css属性有自己的规则，比如vertical-align，为元素下边沿</p><p>4.所有替换元素都是内联水平元素（inline-block、inline、none）</p><p>5.尺寸计算分三类，依照优先级：css尺寸、html尺寸和固有尺寸</p><p>6.替换元素和非替换元素只差一个src（或者content）属性。详见：<a href="https://demo.cssworld.cn/4/1-4.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/1-4.php</a></p></blockquote><p>9.padding的特殊情形：</p><blockquote><p>1.过大的padding值会让box-sizing:border-box无效</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">20px</span> <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>:border-box;</span><br><span class="line">&#125; </span><br><span class="line">最终宽度为120<span class="selector-tag">px</span>(60<span class="selector-tag">px</span>*2)(表现为首选最小宽度)</span><br></pre></td></tr></table></figure><div style="background-color:#98b1d4;margin-bottom:10px;width:80px;padding:20px 60px;box-sizing:border-box"></div><blockquote><p>2.内联元素的宽度和高度都受到padding的影响（可以用于增加点击区域，或者锚点定位降低顶部高度），见案例：<a href="https://demo.cssworld.cn/4/2-1.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/2-1.php</a></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#98b1d4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="border:1px solid grey;margin-bottom:60px"><a style="padding:50px;background-color:#98b1d4">我是测试的链接</a></div><p>10.padding的百分比值是相对于(父元素)宽度width计算的。因为可以据此实现正方形：(或者参考：<a href="https://demo.cssworld.cn/4/2-3.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/2-3.php</a>)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="border:1px solid grey;margin-bottom:10px;width:100px"><div style="background-color:#98b1d4;padding:50%"></div></div><p>11.margin不能改为已设定width的元素宽度，但是可以改变未设定width的块元素宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50px</span>;</span><br><span class="line">    margin:0 -20px;//无效果，宽度依然是50px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="border:1px solid grey;margin-bottom:10px"><div style="background-color:#98b1d4;width:50px;margin:0 -20px;height:50px"></div></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class='father'&gt;&lt;div class='son'&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    margin:0 -20px;//宽度是88px(50+40-1*2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="border:1px solid grey;margin-bottom:10px;width:50px"><div style="background-color:#98b1d4;margin:0 -20px;height:50px"></div></div><blockquote><p>只要元素尺寸表现符合“充分利用可用空间”，无论是垂直方向还是水平方向，都可以通过margin改变尺寸。</p></blockquote><p>12.margin合并</p><p>三种情形：</p><blockquote><p>1.相邻兄弟元素margin合并</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    p&#123;</span><br><span class="line">        margin: 1em 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一行<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第二行<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="border:1px solid grey;margin-bottom:10px"><p style="background-color:#98b1d4;margin:1em 0">p元素1</p><p style="background-color:#98b1d4;margin:1em 0">p元素2</p></div><blockquote><p>2.父元素和第一个/最后一个子元素。参考：<a href="https://demo.cssworld.cn/4/3-3.php" target="_blank" rel="noopener">https://demo.cssworld.cn/4/3-3.php</a></p></blockquote><div style="background:red;margin-bottom:10px"><p style="background-color:#98b1d4;margin-top:20px">p元素1</p><p style="background-color:#98b1d4">p元素2</p></div><p>即子元素设置margin-top，导致父元素产生了margin-top的效果。可以通过以下方法去除</p><blockquote><p>a.父元素设置BFC</p><p>b.父元素设置border-top</p><p>c.父元素设置padding-top</p><p>d.父元素和第一个子元素之间添加内联元素进行分隔</p></blockquote><blockquote><p>3.空块级元素的margin合并。即空块元素的margin-top和margin-bottom合并</p></blockquote><p>13.margin填充规则：见<a href="http://demo.cssworld.cn/4/3-4.php" target="_blank" rel="noopener">http://demo.cssworld.cn/4/3-4.php</a></p><blockquote><p>1.如果一侧是定值，一侧auto，则auto为剩余空间大小</p><p>2.如果两侧均是auto，则平分剩余空间</p></blockquote><p>可以使用margin-left：auto实现块状元素靠右对齐。或者margin：0 auto实现居中对齐。或者实现垂直居中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:auto;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;<span class="attribute">right</span>:<span class="number">0</span>;<span class="attribute">bottom</span>:<span class="number">0</span>;<span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;<span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="background:red;margin-bottom:10px"><div style="background-color:#98b1d4;margin-left:auto;width:300px">内部div</div></div><p>14.border-color默认值就是color色值（类似还有outline、box-shadow、text-shadow）</p><div style="border:1px solid #98b1d4;margin-bottom:10px"><div style="color:red;border:1px solid;margin:5px">内部div</div></div><p>15.vertical-align:middle 指的是基线（字母x下边沿）往上1/2 x-height的高度。也就是字母x的中间点</p><p>16.对于非替换元素的内联元素，可视高度完全由line-height决定</p><div style="border:1px solid #98b1d4;margin-bottom:10px"><p style="line-height:36px;background-color:red">p元素</p></div><p>17.替换元素的高度不受line-height影响</p><input value="123" style="line-height:36px"><p>18.关于文本的垂直居中：</p><blockquote><p>1.单行文本，只需要line-heihgt即可垂直居中</p><p>2.多行文本垂直居中：见（ <a href="https://demo.cssworld.cn/5/2-4.php" target="_blank" rel="noopener">https://demo.cssworld.cn/5/2-4.php</a> ）</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">line-heihgt</span>:<span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#f0f3f9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class="box"&gt;</span><br><span class="line">&lt;div class="content"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><div style="border:1px solid #98b1d4;margin-bottom:10px;line-height:120px"><div style="display:inline-block;line-height:20px;margin:0 20px;vertical-align:middle">基于行高实现的多行文字垂直居中效果，需要vertical-align属性帮助。基于行高实现的多行文字垂直居中效果，需要vertical-align属性帮助。基于行高实现的多行文字垂直居中效果，需要vertical-align属性帮助。基于行高实现的多行文字垂直居中效果，需要vertical-align属性帮助。</div></div><p>19.内联元素line-height的大值特性：无论内联元素如何设置，最终父级元素的高度都是由数值大的那个line-height决定</p><div style="border:1px solid #98b1d4;margin-bottom:10px"><span style="line-height:10px">文本1</span><span style="line-height:30px">文本2</span><span style="line-height:60px">文本3</span></div><p>20.vertical-align属性值分四类：</p><blockquote><p>1.线类，如baseline（默认值，等于数值0）、top、middle、bottom</p><p>2.文本类，如text-top、text-bottom</p><p>3.上标下标类，如sub、super</p><p>4.数值百分比类，如20px、2em、20%（相对于line-height计算）等，正值向上偏移，负值向下。参见：<a href="https://demo.cssworld.cn/5/3-2.php" target="_blank" rel="noopener">https://demo.cssworld.cn/5/3-2.php</a></p></blockquote><p>vertical-align只能应用于内联元素或者display:table-cell的元素。（如果内联元素设置了浮动或绝对定位，则失效）</p><p>21.float特性：参见：<a href="https://demo.cssworld.cn/6/1-1.php" target="_blank" rel="noopener">https://demo.cssworld.cn/6/1-1.php</a></p><blockquote><p>1.包裹性</p><p>2.块状化并格式化上下文</p><p>3.破坏文档流（父元素高度塌陷）</p><p>4.没有margin合并</p></blockquote><p>22.clear：元素盒子的边不能和前面的浮动元素相邻。见例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">20px</span>;<span class="attribute">height</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-of-type(3)</span>&#123;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;//实际结果：两行显示</span><br></pre></td></tr></table></figure><ul style="border:1px solid #98b1d4;margin-bottom:10px"><li style="float:left;background-color:red;width:20px;height:20px;margin:5px">div1</li><li style="clear:both;background-color:#ff0">div2</li></ul><p>23.clear属性只能块级元素有效，因此使用伪元素清除浮动需要设置display：block（或table、list-item等）。另附特殊情况：<a href="https://demo.cssworld.cn/6/2-1.php" target="_blank" rel="noopener">https://demo.cssworld.cn/6/2-1.php</a></p><p>24.BFC（block formatting context）块级格式化上下文：内部元素不管怎么折腾，都不会影响外部的元素。触发条件：</p><blockquote><p>hmtl根元素</p><p>float的值为left、right</p><p>overflow的值为auto、scroll或hidden</p><p>display的值为table-cell、table-caption和inline-block</p><p>position的值为absolute、fixed</p></blockquote><p>25.锚点定位小技巧：</p><blockquote><p>返回顶部</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>返回顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="#">返回顶部</a></p><blockquote><p>快速将输入框移动到屏幕内</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'input'</span>).focus();</span><br></pre></td></tr></table></figure><blockquote><p>设置了overflow：hidden或者scroll的元素也可以使用锚点定位，将当前不可见的元素移动到可见范围</p></blockquote><div style="border:1px solid #98b1d4;margin-bottom:10px;width:100px;height:50px;overflow:hidden"><div style="background-color:red;height:70px;width:100px">内部div内部div内部div内部div内部div内部div内部div内部div内部div <input id="testInput"></div></div><p><a id="testTarget" style="cursor:pointer">点击将隐藏的input可见</a></p><script>var aDom=document.querySelector("#testTarget");aDom.addEventListener("click",function(){console.log("123"),document.querySelector("#testInput").focus()})</script><blockquote><p>无js实现tab切换。参见：<a href="https://demo.cssworld.cn/6/4-2.php" target="_blank" rel="noopener">https://demo.cssworld.cn/6/4-2.php</a> 和 <a href="https://demo.cssworld.cn/6/4-3.php" target="_blank" rel="noopener">https://demo.cssworld.cn/6/4-3.php</a></p></blockquote><p>26.设置绝对定位的span元素，display计算值变成block</p><p>—待重读：absolute的包含块</p><p>27.无依赖的绝对定位：</p><p>​ 单独使用position：absolute即可实现定位（还在元素的原位置），参见<a href="https://demo.cssworld.cn/6/5-4.php" target="_blank" rel="noopener">https://demo.cssworld.cn/6/5-4.php</a></p><p>​ 或者实现图标和文字的对齐：<a href="https://demo.cssworld.cn/6/5-5.php" target="_blank" rel="noopener">https://demo.cssworld.cn/6/5-5.php</a></p><p>​ 或者实现表单的提示信息：<a href="https://demo.cssworld.cn/6/5-6.php" target="_blank" rel="noopener">https://demo.cssworld.cn/6/5-6.php</a></p><p>​ position：absolute的元素设置text-align:center会影响原内联元素，本质上是影响“幽灵空白节点”，参见：<a href="https://demo.cssworld.cn/6/5-8.php" target="_blank" rel="noopener">https://demo.cssworld.cn/6/5-8.php</a></p><div style="border:1px solid #98b1d4;margin-bottom:20px;position:relative;height:50px"><span style="position:absolute">文本</span></div><p>28.如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，这overflow无法对absolute元素进行裁剪。</p><blockquote><p>overflow元素只设置transform的时候，chrome下的overflow裁剪无效</p></blockquote><blockquote><p>裁剪属性clip必须和固定定位(position:relative)和绝对定位(position:absolute)元素一起使用</p></blockquote><blockquote><p>绝对定位元素在对立方向同时发生定位时，具有流体特性（类似diplay:block）。你用流体特性和margin:auto实现居中：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;<span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;<span class="attribute">right</span>:<span class="number">0</span>;<span class="attribute">top</span>:<span class="number">0</span>;<span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="border:1px solid #98b1d4;margin-bottom:30px;position:relative"><span style="position:absolute;left:0;right:0;background-color:red">文本</span></div><p>29.relative相对定位：不影响其他元素</p><blockquote><p>1.与margin的区别：<a href="https://demo.cssworld.cn/6/6-1.php" target="_blank" rel="noopener">https://demo.cssworld.cn/6/6-1.php</a></p><p>2.相反方向同时定位：top比bottom优先，left比right优先</p></blockquote><div style="border:1px solid #98b1d4;margin-bottom:20px"><span style="position:relative;left:20px;top:0">文本</span> <span>文本2</span></div><p>30.position：fixed不设置left、top等（只配合margin），可实现无依赖的固定定位</p><div style="border:1px solid #98b1d4;margin-bottom:20px;position:relative"><span style="position:fixed;margin-left:20px;margin-top:20px">文本</span></div><p>31.z-index层叠顺序</p><blockquote><p>【层叠上下文background和border】&lt;【负的z-index】 &lt; 【block块状水平盒子】 &lt; 【float浮动盒子】 &lt; 【inline水平盒子】 &lt; 【z-index:auto或者看成z-index:0 】 &lt; 【正的z-index】</p><p>基本规则：1.谁大谁上；2.后来居上</p><p>z-index:0 和z-index:auto的区别见<a href="https://demo.cssworld.cn/7/5-1.php。当父元素z-index:auto时，子元素就不受父元素影响，只需要比较子元素；当父元素z-index:0时，就会创建一个层叠上下文，忽略子元素的z-index。按后来居上顺序" target="_blank" rel="noopener">https://demo.cssworld.cn/7/5-1.php。当父元素z-index:auto时，子元素就不受父元素影响，只需要比较子元素；当父元素z-index:0时，就会创建一个层叠上下文，忽略子元素的z-index。按后来居上顺序</a></p><p>定位元素层叠在普通元素之上。原因是其z-index:auto（默认值）生效，也就是0级别</p></blockquote><p>理解层叠上下文：<a href="https://demo.cssworld.cn/7/6-1.php" target="_blank" rel="noopener">https://demo.cssworld.cn/7/6-1.php</a></p><p>32.font-size的关键字属性值</p><blockquote><p>相对尺寸关键字：<br>larger,smaller，相对于当前元素的font-size计算</p></blockquote><blockquote><p>绝对尺寸关键字，受浏览器设置的字号影响<br>xx-large, x-large, large, medium等</p></blockquote><p>或者数值0.实现隐藏文字的作用</p><div style="border:1px solid #98b1d4;margin-bottom:20px"><span style="font-size:0">文本</span></div><p>33.font-family的值有两类：</p><blockquote><p>字体名，如simsun、’Microsoft Yahei’（有空格的需要引号引起来）</p><p>字体族，如serif（衬线字体，笔画末尾有修饰，如宋体），sans-serif（无衬线字体，如微软雅黑）</p></blockquote><p>font-family值可以有多个，用逗号分隔，浏览器会依次往后查找对应字体。</p><div style="border:1px solid #98b1d4;margin-bottom:20px;position:relative"><span style="font-family:'Source Han Sans CN',PingFang-SC-Medium,'Microsoft YaHei'">文本</span></div><p>34.text-indent的特性</p><blockquote><p>text-indent仅对第一行内联盒子内容有效；</p><p>非替换元素以外的display计算值为inline的内联元素设置text-indent无效；</p><p>input标签设置text-indent无效</p><p>button标签设置text-indent有浏览器差异</p></blockquote><div style="border:1px solid #98b1d4;margin-bottom:20px;width:50px;text-indent:10px"><span style="text-indent:10px;background-color:red">文本文本文本文本文本</span></div><p>35.white-space本质上是决定回车、空格是否生效</p><blockquote><p>normal 合并空白字符和换行符</p><p>pre 空白字符不合并，并且内容只在有换行符的地方换行</p><p>nowrap 与normal一样合并空白字符，但不允许文本环绕</p><p>pre-wrap 空白字符不合并，并且只在有换行符的地方换行，同时允许文本环绕</p><p>pre-line 合并空白字符，但只在有换行符的地方换行，允许文本环绕</p></blockquote><div style="border:1px solid #98b1d4;margin-bottom:20px"><span style="white-space:normal;display:inline-block">文本 1</span><br><span style="white-space:pre">文本 1</span><br><span style="white-space:nowrap">文本 1</span><br><span style="white-space:pre-wrap">文本 1</span><br><span style="white-space:pre-line">文本 1</span><br></div><p>36.text-align:justify要实现两端对齐，需要满足：</p><blockquote><p>有分隔点，如空格</p><p>超过一行，此时非最后一行内容会两端对齐</p></blockquote><div style="border:1px solid #98b1d4;margin-bottom:20px;text-align:justify;width:50px;display:inline-block">文本文本文 本文本文本</div><p>37.color的特性</p><blockquote><p><del>不支持transparent值和currentColor变量</del> 已支持transparent值和currentColor变量</p><p><del>不支持rgba颜色（rgba(255,0,0,0.5)）和hsla颜色(hsla(240,100%,50%, .7))</del> 已支持rgba颜色和hsla颜色</p><p>支持系统颜色，如WindowFrame等</p></blockquote><div style="border:1px solid #98b1d4;margin-bottom:20px;color:#ff0"><span style="color:transparent">文本1</span> <span style="color:currentColor">文本2</span> <span style="color:rgba(255,0,0,.5)">文本3</span> <span style="color:hsla(240,100%,50%,.7)">文本4</span> <span style="color:WindowFrame">文本5</span></div><p>38.background-position特性：</p><blockquote><p>缺省值默认为center，如background-position: top center 等同于 background-position: top</p><p>百分比值计算：positionX = (容器宽度 - 图片宽度)*percentX</p></blockquote><p>39.HTML5新增布尔属性：hidden</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">    不显示的内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="border:1px solid #98b1d4;margin-bottom:20px;height:20px"><div hidden>不显示的内容</div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Apr 11 2022 02:53:53 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;标题是唬人的，实际只记录了39条。如下(使用了html效果的，请直接右键查看html源码)：&lt;/p&gt;&lt;p&gt;1.
      
    
    </summary>
    
      <category term="技术" scheme="http://www.kuang2.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS JS基础" scheme="http://www.kuang2.cn/tags/JS-JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
